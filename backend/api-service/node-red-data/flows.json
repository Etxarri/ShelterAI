[
    {
        "id": "tab_shelters",
        "type": "tab",
        "label": "Shelters API",
        "disabled": false,
        "info": "API REST para gestión de albergues"
    },
    {
        "id": "tab_refugees",
        "type": "tab",
        "label": "Refugees API",
        "disabled": false,
        "info": "API REST para gestión de refugiados"
    },
    {
        "id": "tab_assignments",
        "type": "tab",
        "label": "Assignments API",
        "disabled": false,
        "info": "API REST para gestión de asignaciones"
    },
    {
        "id": "tab_ai_integration",
        "type": "tab",
        "label": "AI Integration",
        "disabled": false,
        "info": "Integración con el servicio de IA para asignación automática de refugios"
    },
    {
        "id": "tab_login",
        "type": "tab",
        "label": "Auth API",
        "disabled": false,
        "info": "API para autenticación y login"
    },
    {
        "id": "301245f94e1239d9",
        "type": "postgreSQLConfig",
        "name": "ShelterAI DB",
        "host": "postgres",
        "hostFieldType": "str",
        "port": 5432,
        "portFieldType": "num",
        "database": "shelterai",
        "databaseFieldType": "str",
        "ssl": "false",
        "sslFieldType": "bool",
        "applicationName": "",
        "applicationNameType": "str",
        "max": 10,
        "maxFieldType": "num",
        "idle": 1000,
        "idleFieldType": "num",
        "connectionTimeout": 10000,
        "connectionTimeoutFieldType": "num",
        "user": "root",
        "userFieldType": "str",
        "password": "root",
        "passwordFieldType": "str"
    },
    {
        "id": "shelter_get_all",
        "type": "http in",
        "z": "tab_shelters",
        "name": "GET /api/shelters",
        "url": "/api/shelters",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 80,
        "wires": [
            [
                "shelter_get_all_query"
            ]
        ]
    },
    {
        "id": "shelter_get_all_query",
        "type": "postgresql",
        "z": "tab_shelters",
        "name": "Query All Shelters",
        "query": "SELECT * FROM shelters ORDER BY id",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 370,
        "y": 80,
        "wires": [
            [
                "shelter_response"
            ]
        ]
    },
    {
        "id": "shelter_get_by_id",
        "type": "http in",
        "z": "tab_shelters",
        "name": "GET /api/shelters/:id",
        "url": "/api/shelters/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 140,
        "wires": [
            [
                "shelter_get_by_id_prepare"
            ]
        ]
    },
    {
        "id": "shelter_get_by_id_prepare",
        "type": "function",
        "z": "tab_shelters",
        "name": "Prepare Query",
        "func": "msg.queryParameters = [parseInt(msg.req.params.id)];\nmsg.payload = \"SELECT * FROM shelters WHERE id = $1\";\nreturn msg;",
        "outputs": 1,
        "x": 380,
        "y": 140,
        "wires": [
            [
                "shelter_get_by_id_query"
            ]
        ]
    },
    {
        "id": "shelter_get_by_id_query",
        "type": "postgresql",
        "z": "tab_shelters",
        "name": "Query Shelter",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 580,
        "y": 140,
        "wires": [
            [
                "shelter_single_response"
            ]
        ]
    },
    {
        "id": "shelter_get_available",
        "type": "http in",
        "z": "tab_shelters",
        "name": "GET /api/shelters/available",
        "url": "/api/shelters/available",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 200,
        "wires": [
            [
                "shelter_get_available_query"
            ]
        ]
    },
    {
        "id": "shelter_get_available_query",
        "type": "postgresql",
        "z": "tab_shelters",
        "name": "Query Available",
        "query": "SELECT * FROM shelters WHERE current_occupancy < max_capacity ORDER BY id",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 410,
        "y": 200,
        "wires": [
            [
                "shelter_response"
            ]
        ]
    },
    {
        "id": "shelter_post",
        "type": "http in",
        "z": "tab_shelters",
        "d": true,
        "name": "POST /api/shelters",
        "url": "/api/shelters",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 260,
        "wires": [
            [
                "shelter_post_prepare"
            ]
        ]
    },
    {
        "id": "shelter_post_prepare",
        "type": "function",
        "z": "tab_shelters",
        "d": true,
        "name": "Prepare Insert",
        "func": "const data = msg.payload;\nmsg.queryParameters = [\n    data.name, data.address, data.phone_number, data.email,\n    data.max_capacity, data.current_occupancy || 0,\n    data.has_medical_facilities || false, data.has_childcare || false,\n    data.has_disability_access || false, data.languages_spoken,\n    data.latitude, data.longitude, data.shelter_type, data.services_offered\n];\nmsg.payload = `INSERT INTO shelters (name, address, phone_number, email, max_capacity, current_occupancy, has_medical_facilities, has_childcare, has_disability_access, languages_spoken, latitude, longitude, shelter_type, services_offered, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) RETURNING *`;\nreturn msg;",
        "outputs": 1,
        "x": 370,
        "y": 260,
        "wires": [
            [
                "shelter_post_query"
            ]
        ]
    },
    {
        "id": "shelter_post_query",
        "type": "postgresql",
        "z": "tab_shelters",
        "d": true,
        "name": "Insert Shelter",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 570,
        "y": 260,
        "wires": [
            [
                "shelter_created_response"
            ]
        ]
    },
    {
        "id": "shelter_put",
        "type": "http in",
        "z": "tab_shelters",
        "d": true,
        "name": "PUT /api/shelters/:id",
        "url": "/api/shelters/:id",
        "method": "put",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 320,
        "wires": [
            [
                "shelter_put_prepare"
            ]
        ]
    },
    {
        "id": "shelter_put_prepare",
        "type": "function",
        "z": "tab_shelters",
        "d": true,
        "name": "Prepare Update",
        "func": "const data = msg.payload;\nconst id = parseInt(msg.req.params.id);\nmsg.queryParameters = [\n    data.name, data.address, data.phone_number, data.email,\n    data.max_capacity, data.current_occupancy,\n    data.has_medical_facilities, data.has_childcare,\n    data.has_disability_access, data.languages_spoken,\n    data.latitude, data.longitude, data.shelter_type, data.services_offered, id\n];\nmsg.payload = `UPDATE shelters SET name=$1, address=$2, phone_number=$3, email=$4, max_capacity=$5, current_occupancy=$6, has_medical_facilities=$7, has_childcare=$8, has_disability_access=$9, languages_spoken=$10, latitude=$11, longitude=$12, shelter_type=$13, services_offered=$14, updated_at=CURRENT_TIMESTAMP WHERE id=$15 RETURNING *`;\nreturn msg;",
        "outputs": 1,
        "x": 370,
        "y": 320,
        "wires": [
            [
                "shelter_put_query"
            ]
        ]
    },
    {
        "id": "shelter_put_query",
        "type": "postgresql",
        "z": "tab_shelters",
        "d": true,
        "name": "Update Shelter",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 580,
        "y": 320,
        "wires": [
            [
                "shelter_single_response"
            ]
        ]
    },
    {
        "id": "shelter_delete",
        "type": "http in",
        "z": "tab_shelters",
        "d": true,
        "name": "DELETE /api/shelters/:id",
        "url": "/api/shelters/:id",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 380,
        "wires": [
            [
                "shelter_delete_prepare"
            ]
        ]
    },
    {
        "id": "shelter_delete_prepare",
        "type": "function",
        "z": "tab_shelters",
        "d": true,
        "name": "Prepare Delete",
        "func": "msg.queryParameters = [parseInt(msg.req.params.id)];\nmsg.payload = \"DELETE FROM shelters WHERE id = $1\";\nreturn msg;",
        "outputs": 1,
        "x": 380,
        "y": 380,
        "wires": [
            [
                "shelter_delete_query"
            ]
        ]
    },
    {
        "id": "shelter_delete_query",
        "type": "postgresql",
        "z": "tab_shelters",
        "d": true,
        "name": "Delete Shelter",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 580,
        "y": 380,
        "wires": [
            [
                "shelter_delete_response"
            ]
        ]
    },
    {
        "id": "shelter_response",
        "type": "function",
        "z": "tab_shelters",
        "name": "Format Response",
        "func": "msg.statusCode = 200;\nmsg.payload = msg.payload || [];\nreturn msg;",
        "outputs": 1,
        "x": 790,
        "y": 80,
        "wires": [
            [
                "shelter_http_response"
            ]
        ]
    },
    {
        "id": "shelter_single_response",
        "type": "function",
        "z": "tab_shelters",
        "name": "Format Single",
        "func": "if (msg.payload && msg.payload.length > 0) {\n    msg.statusCode = 200;\n    msg.payload = msg.payload[0];\n} else {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Shelter not found\" };\n}\nreturn msg;",
        "outputs": 1,
        "x": 780,
        "y": 140,
        "wires": [
            [
                "shelter_http_response"
            ]
        ]
    },
    {
        "id": "shelter_created_response",
        "type": "function",
        "z": "tab_shelters",
        "d": true,
        "name": "Format Created",
        "func": "msg.statusCode = 201;\nmsg.payload = msg.payload[0];\nreturn msg;",
        "outputs": 1,
        "x": 790,
        "y": 260,
        "wires": [
            [
                "shelter_http_response"
            ]
        ]
    },
    {
        "id": "shelter_delete_response",
        "type": "function",
        "z": "tab_shelters",
        "d": true,
        "name": "Format Delete",
        "func": "msg.statusCode = 204;\nmsg.payload = \"\";\nreturn msg;",
        "outputs": 1,
        "x": 780,
        "y": 380,
        "wires": [
            [
                "shelter_http_response"
            ]
        ]
    },
    {
        "id": "shelter_http_response",
        "type": "http response",
        "z": "tab_shelters",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1000,
        "y": 220,
        "wires": []
    },
    {
        "id": "refugee_get_all",
        "type": "http in",
        "z": "tab_refugees",
        "name": "GET /api/refugees",
        "url": "/api/refugees",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 80,
        "wires": [
            [
                "refugee_get_all_query"
            ]
        ]
    },
    {
        "id": "refugee_get_all_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "name": "Query All Refugees",
        "query": "SELECT * FROM refugees WHERE assigned_shelter_id IS NULL OR status != 'assigned' ORDER BY id",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 370,
        "y": 80,
        "wires": [
            [
                "refugee_response"
            ]
        ]
    },
    {
        "id": "refugee_get_assigned",
        "type": "http in",
        "z": "tab_refugees",
        "name": "GET /api/refugees/assigned",
        "url": "/api/refugees/assigned",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 500,
        "wires": [
            [
                "refugee_get_assigned_query"
            ]
        ]
    },
    {
        "id": "refugee_get_assigned_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "name": "Query Assigned Refugees",
        "query": "SELECT r.*, s.name as shelter_name, s.address as shelter_address FROM refugees r LEFT JOIN shelters s ON r.assigned_shelter_id = s.id WHERE r.assigned_shelter_id IS NOT NULL AND r.status = 'assigned' ORDER BY r.updated_at DESC",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 410,
        "y": 500,
        "wires": [
            [
                "refugee_response"
            ]
        ]
    },
    {
        "id": "refugee_get_by_id",
        "type": "http in",
        "z": "tab_refugees",
        "name": "GET /api/refugees/:id",
        "url": "/api/refugees/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 140,
        "wires": [
            [
                "refugee_get_by_id_prepare"
            ]
        ]
    },
    {
        "id": "refugee_get_by_id_prepare",
        "type": "function",
        "z": "tab_refugees",
        "name": "Prepare Query",
        "func": "const data = msg.payload;\n\nmsg.topic = `INSERT INTO refugees (first_name, last_name, age, gender, nationality, languages_spoken, family_id, medical_conditions, has_disability, special_needs, vulnerability_score, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) RETURNING *`;\n\nmsg.params = [\n    parseInt(msg.req.params.id)\n];\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 140,
        "wires": [
            [
                "refugee_get_by_id_query"
            ]
        ]
    },
    {
        "id": "refugee_get_by_id_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "name": "Query Refugee",
        "query": "{{msg.topic}}",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 580,
        "y": 140,
        "wires": [
            [
                "refugee_single_response"
            ]
        ]
    },
    {
        "id": "refugee_get_by_family",
        "type": "http in",
        "z": "tab_refugees",
        "d": true,
        "name": "GET /api/refugees/family/:familyId",
        "url": "/api/refugees/family/:familyId",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 200,
        "wires": [
            [
                "refugee_get_by_family_prepare"
            ]
        ]
    },
    {
        "id": "refugee_get_by_family_prepare",
        "type": "function",
        "z": "tab_refugees",
        "d": true,
        "name": "Prepare Query",
        "func": "msg.queryParameters = [parseInt(msg.req.params.familyId)];\nmsg.payload = \"SELECT * FROM refugees WHERE family_id = $1 ORDER BY id\";\nreturn msg;",
        "outputs": 1,
        "x": 430,
        "y": 200,
        "wires": [
            [
                "refugee_get_by_family_query"
            ]
        ]
    },
    {
        "id": "refugee_get_by_family_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "d": true,
        "name": "Query",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 630,
        "y": 200,
        "wires": [
            [
                "refugee_response"
            ]
        ]
    },
    {
        "id": "refugee_get_high_vulnerability",
        "type": "http in",
        "z": "tab_refugees",
        "d": true,
        "name": "GET /api/refugees/high-vulnerability",
        "url": "/api/refugees/high-vulnerability",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 260,
        "wires": [
            [
                "refugee_get_high_vuln_prepare"
            ]
        ]
    },
    {
        "id": "refugee_get_high_vuln_prepare",
        "type": "function",
        "z": "tab_refugees",
        "d": true,
        "name": "Prepare Query",
        "func": "const minScore = parseFloat(msg.req.query.minScore) || 7.0;\nmsg.queryParameters = [minScore];\nmsg.payload = \"SELECT * FROM refugees WHERE vulnerability_score >= $1 ORDER BY vulnerability_score DESC\";\nreturn msg;",
        "outputs": 1,
        "x": 450,
        "y": 260,
        "wires": [
            [
                "refugee_get_high_vuln_query"
            ]
        ]
    },
    {
        "id": "refugee_get_high_vuln_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "d": true,
        "name": "Query",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 650,
        "y": 260,
        "wires": [
            [
                "refugee_response"
            ]
        ]
    },
    {
        "id": "refugee_post",
        "type": "http in",
        "z": "tab_refugees",
        "name": "POST /api/refugees",
        "url": "/api/refugees",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 320,
        "wires": [
            [
                "refugee_post_prepare"
            ]
        ]
    },
    {
        "id": "refugee_post_prepare",
        "type": "function",
        "z": "tab_refugees",
        "name": "Prepare Insert",
        "func": "const data = msg.payload;\n\nmsg.topic = `INSERT INTO refugees (first_name, last_name, age, gender, nationality, languages_spoken, family_id, medical_conditions, has_disability, special_needs, vulnerability_score, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) RETURNING *`;\n\nmsg.params = [\n    data.first_name, \n    data.last_name, \n    data.age, \n    data.gender,\n    data.nationality, \n    data.languages_spoken, \n    data.family_id,\n    data.medical_conditions,\n    data.has_disability,\n    data.special_needs, \n    data.vulnerability_score || 0\n];\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 320,
        "wires": [
            [
                "refugee_post_query"
            ]
        ]
    },
    {
        "id": "refugee_post_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "name": "Insert Refugee",
        "query": "{{msg.topic}}",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 560,
        "y": 320,
        "wires": [
            [
                "refugee_created_response"
            ]
        ]
    },
    {
        "id": "refugee_put",
        "type": "http in",
        "z": "tab_refugees",
        "d": true,
        "name": "PUT /api/refugees/:id",
        "url": "/api/refugees/:id",
        "method": "put",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 380,
        "wires": [
            [
                "refugee_put_prepare"
            ]
        ]
    },
    {
        "id": "refugee_put_prepare",
        "type": "function",
        "z": "tab_refugees",
        "d": true,
        "name": "Prepare Update",
        "func": "const data = msg.payload;\nconst id = parseInt(msg.req.params.id);\nmsg.queryParameters = [\n    data.first_name, data.last_name, data.age, data.gender,\n    data.nationality, data.languages_spoken, data.phone_number,\n    data.email, data.family_id, data.medical_conditions,\n    data.special_needs, data.vulnerability_score,\n    data.education_level, data.employment_status, data.registration_date, id\n];\nmsg.payload = `UPDATE refugees SET first_name=$1, last_name=$2, age=$3, gender=$4, nationality=$5, languages_spoken=$6, phone_number=$7, email=$8, family_id=$9, medical_conditions=$10, special_needs=$11, vulnerability_score=$12, education_level=$13, employment_status=$14, registration_date=$15, updated_at=CURRENT_TIMESTAMP WHERE id=$16 RETURNING *`;\nreturn msg;",
        "outputs": 1,
        "x": 370,
        "y": 380,
        "wires": [
            [
                "refugee_put_query"
            ]
        ]
    },
    {
        "id": "refugee_put_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "d": true,
        "name": "Update Refugee",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 580,
        "y": 380,
        "wires": [
            [
                "refugee_single_response"
            ]
        ]
    },
    {
        "id": "refugee_delete",
        "type": "http in",
        "z": "tab_refugees",
        "d": true,
        "name": "DELETE /api/refugees/:id",
        "url": "/api/refugees/:id",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 440,
        "wires": [
            [
                "refugee_delete_prepare"
            ]
        ]
    },
    {
        "id": "refugee_delete_prepare",
        "type": "function",
        "z": "tab_refugees",
        "d": true,
        "name": "Prepare Delete",
        "func": "msg.queryParameters = [parseInt(msg.req.params.id)];\nmsg.payload = \"DELETE FROM refugees WHERE id = $1\";\nreturn msg;",
        "outputs": 1,
        "x": 380,
        "y": 440,
        "wires": [
            [
                "refugee_delete_query"
            ]
        ]
    },
    {
        "id": "refugee_delete_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "d": true,
        "name": "Delete Refugee",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 580,
        "y": 440,
        "wires": [
            [
                "refugee_delete_response"
            ]
        ]
    },
    {
        "id": "refugee_response",
        "type": "function",
        "z": "tab_refugees",
        "name": "Format Response",
        "func": "msg.statusCode = 200;\nmsg.payload = msg.payload || [];\nreturn msg;",
        "outputs": 1,
        "x": 790,
        "y": 80,
        "wires": [
            [
                "refugee_http_response"
            ]
        ]
    },
    {
        "id": "refugee_single_response",
        "type": "function",
        "z": "tab_refugees",
        "name": "Format Single",
        "func": "if (msg.payload && msg.payload.length > 0) {\n    msg.statusCode = 200;\n    msg.payload = msg.payload[0];\n} else {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Refugee not found\" };\n}\nreturn msg;",
        "outputs": 1,
        "x": 780,
        "y": 140,
        "wires": [
            [
                "refugee_http_response"
            ]
        ]
    },
    {
        "id": "refugee_created_response",
        "type": "function",
        "z": "tab_refugees",
        "name": "Format Created",
        "func": "msg.statusCode = 201;\nmsg.payload = msg.payload[0] || msg.payload; \nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 320,
        "wires": [
            [
                "refugee_http_response"
            ]
        ]
    },
    {
        "id": "refugee_delete_response",
        "type": "function",
        "z": "tab_refugees",
        "d": true,
        "name": "Format Delete",
        "func": "msg.statusCode = 204;\nmsg.payload = \"\";\nreturn msg;",
        "outputs": 1,
        "x": 780,
        "y": 440,
        "wires": [
            [
                "refugee_http_response"
            ]
        ]
    },
    {
        "id": "refugee_http_response",
        "type": "http response",
        "z": "tab_refugees",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1020,
        "y": 320,
        "wires": []
    },
    {
        "id": "assignment_get_all",
        "type": "http in",
        "z": "tab_assignments",
        "d": true,
        "name": "GET /api/assignments",
        "url": "/api/assignments",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 80,
        "wires": [
            [
                "assignment_get_all_query"
            ]
        ]
    },
    {
        "id": "assignment_get_all_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "d": true,
        "name": "Query All Assignments",
        "query": "SELECT * FROM assignments ORDER BY id",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 420,
        "y": 80,
        "wires": [
            [
                "assignment_response"
            ]
        ]
    },
    {
        "id": "assignment_get_by_id",
        "type": "http in",
        "z": "tab_assignments",
        "name": "GET /api/assignments/:id",
        "url": "/api/assignments/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 720,
        "wires": [
            [
                "assignment_get_by_id_prepare"
            ]
        ]
    },
    {
        "id": "assignment_get_by_id_prepare",
        "type": "function",
        "z": "tab_assignments",
        "name": "Prepare Query",
        "func": "var idRefugiado = (msg.req && msg.req.params && msg.req.params.id) || msg.payload || 1;\nvar idNumero = parseInt(idRefugiado);\n\nmsg.topic = `SELECT * FROM assignments WHERE refugee_id = $1 ORDER BY created_at DESC`;\n\nmsg.params = [\n    idNumero\n];\n\n// Pasamos los parámetros al payload para que el nodo Postgres los lea\nmsg.payload = msg.params;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 720,
        "wires": [
            [
                "assignment_get_by_id_query",
                "9aafc1cfb84bc8c1"
            ]
        ]
    },
    {
        "id": "assignment_get_by_id_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "name": "Query Assignment",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 730,
        "y": 720,
        "wires": [
            [
                "5685489b661371a8",
                "assignment_http_response"
            ]
        ]
    },
    {
        "id": "assignment_get_by_refugee",
        "type": "http in",
        "z": "tab_assignments",
        "name": "GET /api/assignments/refugee/:refugeeId",
        "url": "/api/assignments/refugee/:refugeeId",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 200,
        "wires": [
            [
                "assignment_get_by_refugee_prepare"
            ]
        ]
    },
    {
        "id": "assignment_get_by_refugee_prepare",
        "type": "function",
        "z": "tab_assignments",
        "name": "Prepare Query",
        "func": "msg.params = [parseInt(msg.req.params.refugeeId)];\nmsg.topic = \"SELECT a.*, s.name as shelter_name FROM assignments a LEFT JOIN shelters s ON a.shelter_id = s.id WHERE a.refugee_id = $1 ORDER BY a.id DESC\";\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 200,
        "wires": [
            [
                "assignment_get_by_refugee_query"
            ]
        ]
    },
    {
        "id": "assignment_get_by_refugee_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "name": "Query",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 670,
        "y": 200,
        "wires": [
            [
                "assignment_response"
            ]
        ]
    },
    {
        "id": "assignment_get_by_shelter",
        "type": "http in",
        "z": "tab_assignments",
        "d": true,
        "name": "GET /api/assignments/shelter/:shelterId",
        "url": "/api/assignments/shelter/:shelterId",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 260,
        "wires": [
            [
                "assignment_get_by_shelter_prepare"
            ]
        ]
    },
    {
        "id": "assignment_get_by_shelter_prepare",
        "type": "function",
        "z": "tab_assignments",
        "d": true,
        "name": "Prepare Query",
        "func": "msg.queryParameters = [parseInt(msg.req.params.shelterId)];\nmsg.payload = \"SELECT * FROM assignments WHERE shelter_id = $1 ORDER BY id\";\nreturn msg;",
        "outputs": 1,
        "x": 470,
        "y": 260,
        "wires": [
            [
                "assignment_get_by_shelter_query"
            ]
        ]
    },
    {
        "id": "assignment_get_by_shelter_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "d": true,
        "name": "Query",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 670,
        "y": 260,
        "wires": [
            [
                "assignment_response"
            ]
        ]
    },
    {
        "id": "assignment_get_by_status",
        "type": "http in",
        "z": "tab_assignments",
        "d": true,
        "name": "GET /api/assignments/status/:status",
        "url": "/api/assignments/status/:status",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 320,
        "wires": [
            [
                "assignment_get_by_status_prepare"
            ]
        ]
    },
    {
        "id": "assignment_get_by_status_prepare",
        "type": "function",
        "z": "tab_assignments",
        "d": true,
        "name": "Prepare Query",
        "func": "msg.queryParameters = [msg.req.params.status];\nmsg.payload = \"SELECT * FROM assignments WHERE status = $1 ORDER BY id\";\nreturn msg;",
        "outputs": 1,
        "x": 450,
        "y": 320,
        "wires": [
            [
                "assignment_get_by_status_query"
            ]
        ]
    },
    {
        "id": "assignment_get_by_status_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "d": true,
        "name": "Query",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 670,
        "y": 320,
        "wires": [
            [
                "assignment_response"
            ]
        ]
    },
    {
        "id": "assignment_post",
        "type": "http in",
        "z": "tab_assignments",
        "d": true,
        "name": "POST /api/assignments",
        "url": "/api/assignments",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 380,
        "wires": [
            [
                "assignment_post_prepare"
            ]
        ]
    },
    {
        "id": "assignment_post_prepare",
        "type": "function",
        "z": "tab_assignments",
        "d": true,
        "name": "Prepare Insert",
        "func": "const data = msg.payload;\nmsg.queryParameters = [\n    data.refugee_id, data.shelter_id, data.assignment_date,\n    data.status || 'PENDING', data.priority_score, data.notes\n];\nmsg.payload = `INSERT INTO assignments (refugee_id, shelter_id, assignment_date, status, priority_score, notes, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) RETURNING *`;\nreturn msg;",
        "outputs": 1,
        "x": 380,
        "y": 380,
        "wires": [
            [
                "assignment_post_query"
            ]
        ]
    },
    {
        "id": "assignment_post_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "d": true,
        "name": "Insert Assignment",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 590,
        "y": 380,
        "wires": [
            [
                "assignment_created_response"
            ]
        ]
    },
    {
        "id": "assignment_put",
        "type": "http in",
        "z": "tab_assignments",
        "d": true,
        "name": "PUT /api/assignments/:id",
        "url": "/api/assignments/:id",
        "method": "put",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 440,
        "wires": [
            [
                "assignment_put_prepare"
            ]
        ]
    },
    {
        "id": "assignment_put_prepare",
        "type": "function",
        "z": "tab_assignments",
        "d": true,
        "name": "Prepare Update",
        "func": "const data = msg.payload;\nconst id = parseInt(msg.req.params.id);\nmsg.queryParameters = [\n    data.refugee_id, data.shelter_id, data.assignment_date,\n    data.status, data.priority_score, data.notes, id\n];\nmsg.payload = `UPDATE assignments SET refugee_id=$1, shelter_id=$2, assignment_date=$3, status=$4, priority_score=$5, notes=$6, updated_at=CURRENT_TIMESTAMP WHERE id=$7 RETURNING *`;\nreturn msg;",
        "outputs": 1,
        "x": 380,
        "y": 440,
        "wires": [
            [
                "assignment_put_query"
            ]
        ]
    },
    {
        "id": "assignment_put_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "d": true,
        "name": "Update Assignment",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "assignment_delete",
        "type": "http in",
        "z": "tab_assignments",
        "d": true,
        "name": "DELETE /api/assignments/:id",
        "url": "/api/assignments/:id",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 500,
        "wires": [
            [
                "assignment_delete_prepare"
            ]
        ]
    },
    {
        "id": "assignment_delete_prepare",
        "type": "function",
        "z": "tab_assignments",
        "d": true,
        "name": "Prepare Delete",
        "func": "msg.queryParameters = [parseInt(msg.req.params.id)];\nmsg.payload = \"DELETE FROM assignments WHERE id = $1\";\nreturn msg;",
        "outputs": 1,
        "x": 390,
        "y": 500,
        "wires": [
            [
                "assignment_delete_query"
            ]
        ]
    },
    {
        "id": "assignment_delete_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "d": true,
        "name": "Delete Assignment",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 500,
        "wires": [
            [
                "assignment_delete_response",
                "435d2f91358fdeb3"
            ]
        ]
    },
    {
        "id": "assignment_response",
        "type": "function",
        "z": "tab_assignments",
        "name": "Format Response",
        "func": "msg.statusCode = 200;\nmsg.payload = msg.payload || [];\nreturn msg;",
        "outputs": 1,
        "x": 810,
        "y": 80,
        "wires": [
            [
                "assignment_http_response"
            ]
        ]
    },
    {
        "id": "assignment_created_response",
        "type": "function",
        "z": "tab_assignments",
        "d": true,
        "name": "Format Created",
        "func": "msg.statusCode = 201;\nmsg.payload = msg.payload[0];\nreturn msg;",
        "outputs": 1,
        "x": 810,
        "y": 380,
        "wires": [
            [
                "assignment_http_response"
            ]
        ]
    },
    {
        "id": "assignment_delete_response",
        "type": "function",
        "z": "tab_assignments",
        "d": true,
        "name": "Format Delete",
        "func": "msg.statusCode = 204;\nmsg.payload = \"\";\nreturn msg;",
        "outputs": 1,
        "x": 800,
        "y": 500,
        "wires": [
            [
                "assignment_http_response"
            ]
        ]
    },
    {
        "id": "assignment_http_response",
        "type": "http response",
        "z": "tab_assignments",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1020,
        "y": 720,
        "wires": []
    },
    {
        "id": "5685489b661371a8",
        "type": "debug",
        "z": "tab_assignments",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 860,
        "y": 800,
        "wires": []
    },
    {
        "id": "9aafc1cfb84bc8c1",
        "type": "debug",
        "z": "tab_assignments",
        "name": "debug 5",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 800,
        "wires": []
    },
    {
        "id": "435d2f91358fdeb3",
        "type": "debug",
        "z": "tab_assignments",
        "d": true,
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 580,
        "wires": []
    },
    {
        "id": "ai_process_response",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Procesar respuesta IA",
        "func": "// La nueva respuesta del servicio IA contiene array de recommendations\nconst aiResponse = msg.payload;\n\nif (!aiResponse.recommendations || aiResponse.recommendations.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"No se encontraron recomendaciones de refugios\" };\n    return msg;\n}\n\n// Tomar la primera recomendación (mejor match)\nconst topRecommendation = aiResponse.recommendations[0];\n\n// Normalizar confidence_score de 0-100 a 0-1 para Flutter\nconst confidenceNormalized = topRecommendation.confidence_score / 100;\n\n// Formatear alternativas\nconst alternatives = aiResponse.recommendations.slice(1, 4).map(rec => ({\n    shelter_id: rec.shelter_id,\n    shelter_name: rec.shelter_name,\n    confidence_score: rec.confidence_score / 100,  // Normalizar\n    total_score: rec.total_score\n}));\n\n// Formatear respuesta completa\nmsg.payload = {\n    shelter_id: topRecommendation.shelter_id,\n    shelter_name: topRecommendation.shelter_name,\n    confidence_score: confidenceNormalized,\n    priority_score: topRecommendation.total_score,\n    explanation: topRecommendation.explanation,\n    match_details: topRecommendation.match_details,\n    alternative_shelters: alternatives\n};\n\nmsg.statusCode = 200;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 100,
        "wires": [
            [
                "ai_http_response"
            ]
        ]
    },
    {
        "id": "ai_http_response",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Respuesta HTTP",
        "statusCode": "",
        "headers": {},
        "x": 1130,
        "y": 100,
        "wires": []
    },
    {
        "id": "refugee_post_with_ai",
        "type": "http in",
        "z": "tab_ai_integration",
        "name": "POST /api/refugees-with-assignment",
        "url": "/api/refugees-with-assignment",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 160,
        "wires": [
            [
                "save_refugee_first"
            ]
        ]
    },
    {
        "id": "save_refugee_first",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Preparar INSERT refugiado",
        "func": "const data = msg.payload;\n\n// Guardar datos completos para después\nflow.set('tempRefugeeData', data);\n\nmsg.topic = `INSERT INTO refugees (first_name, last_name, age, gender, nationality, languages_spoken, family_id, medical_conditions, has_disability, special_needs, vulnerability_score, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) RETURNING *`;\n\nmsg.params = [\n    data.first_name, \n    data.last_name, \n    data.age, \n    data.gender,\n    data.nationality, \n    data.languages_spoken, \n    data.family_id,\n    data.medical_conditions,\n    data.has_disability || false,\n    data.special_needs, \n    data.vulnerability_score || 0\n];\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 160,
        "wires": [
            [
                "insert_refugee_db"
            ]
        ]
    },
    {
        "id": "insert_refugee_db",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "Guardar refugiado",
        "query": "{{msg.topic}}",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 730,
        "y": 160,
        "wires": [
            [
                "prepare_ai_call"
            ]
        ]
    },
    {
        "id": "prepare_ai_call",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Guardar refugiado para contexto",
        "func": "// El refugiado ya está guardado en la BD\nconst savedRefugee = msg.payload[0];\n\n// Guardar refugiado para la respuesta final\nflow.set('savedRefugee', savedRefugee);\n\n// IMPORTANTE: Limpiar params para la siguiente consulta\ndelete msg.params;\ndelete msg.topic;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 160,
        "wires": [
            [
                "query_available_shelters"
            ]
        ]
    },
    {
        "id": "query_available_shelters",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "Obtener refugios disponibles",
        "query": "SELECT id, name, max_capacity, current_occupancy, has_medical_facilities, has_childcare, has_disability_access, languages_spoken FROM shelters WHERE current_occupancy < max_capacity ORDER BY id",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 160,
        "y": 240,
        "wires": [
            [
                "prepare_ai_request"
            ]
        ]
    },
    {
        "id": "prepare_ai_request",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Preparar request para IA",
        "func": "const savedRefugee = flow.get('savedRefugee');\n\n// Calcular family_size, has_children, children_count\nlet family_size = 1;\nlet has_children = false;\nlet children_count = 0;\n\nif (savedRefugee.family_id) {\n    // TODO: Obtener datos reales de familia si es necesario\n    family_size = 1;\n}\n\n// Preparar payload para el servicio de IA (ya no enviamos lista de shelters)\nmsg.payload = {\n    first_name: savedRefugee.first_name,\n    last_name: savedRefugee.last_name,\n    age: savedRefugee.age,\n    gender: savedRefugee.gender,\n    nationality: savedRefugee.nationality,\n    languages_spoken: savedRefugee.languages_spoken,\n    medical_conditions: savedRefugee.medical_conditions,\n    has_disability: savedRefugee.has_disability,\n    vulnerability_score: savedRefugee.vulnerability_score,\n    special_needs: savedRefugee.special_needs,\n    family_id: savedRefugee.family_id,\n    family_size: family_size,\n    has_children: has_children,\n    children_count: children_count\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 240,
        "wires": [
            [
                "call_ai_for_assignment"
            ]
        ]
    },
    {
        "id": "call_ai_for_assignment",
        "type": "http request",
        "z": "tab_ai_integration",
        "name": "Obtener asignación IA",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://shelterai-ai-service:8000/api/recommend",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Content-Type",
                "keyValue": "",
                "valueType": "application/json",
                "valueValue": ""
            }
        ],
        "x": 700,
        "y": 240,
        "wires": [
            [
                "create_assignment"
            ]
        ]
    },
    {
        "id": "create_assignment",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Crear asignación en BD",
        "func": "const aiResponse = msg.payload;\nconst savedRefugee = flow.get('savedRefugee');\n\n// Validar que la respuesta tiene el formato correcto\nif (!aiResponse.recommendations || aiResponse.recommendations.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"No se encontraron recomendaciones de refugios\" };\n    return [null, msg];  // Enviar por output de error\n}\n\n// Tomar la mejor recomendación\nconst topRec = aiResponse.recommendations[0];\n\n// Verificar que tiene shelter_id\nif (!topRec.shelter_id) {\n    msg.statusCode = 500;\n    msg.payload = { error: \"Respuesta de IA inválida: falta shelter_id\" };\n    return [null, msg];  // Enviar por output de error\n}\n\n// Preparar INSERT de la asignación\nmsg.topic = `INSERT INTO assignments (refugee_id, shelter_id, assigned_at, status, priority_score, explanation, assigned_by, created_at, updated_at) VALUES ($1, $2, CURRENT_TIMESTAMP, $3, $4, $5, $6, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) RETURNING *`;\n\nmsg.params = [\n    savedRefugee.id,\n    topRec.shelter_id,\n    'pending',\n    topRec.total_score,\n    topRec.explanation,\n    'AI-System'\n];\n\n// Guardar respuesta IA completa para después\nflow.set('aiResponse', aiResponse);\n\nreturn [msg, null];  // Enviar por output normal",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 190,
        "y": 340,
        "wires": [
            [
                "insert_assignment_db"
            ],
            [
                "final_http_response"
            ]
        ]
    },
    {
        "id": "insert_assignment_db",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "Guardar asignación",
        "query": "{{msg.topic}}",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 510,
        "y": 340,
        "wires": [
            [
                "format_final_response"
            ]
        ]
    },
    {
        "id": "format_final_response",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Formatear respuesta final",
        "func": "const savedRefugee = flow.get('savedRefugee');\nconst aiResponse = flow.get('aiResponse');\nconst assignment = msg.payload[0];\n\n// Obtener la mejor recomendación\nconst topRec = aiResponse.recommendations[0];\n\n// Normalizar confidence_score de 0-100 a 0-1 para Flutter\nconst confidenceNormalized = topRec.confidence_score / 100;\n\n// Formatear alternativas\nconst alternatives = aiResponse.recommendations.slice(1, 4).map(rec => ({\n    shelter_id: rec.shelter_id,\n    shelter_name: rec.shelter_name,\n    confidence_score: rec.confidence_score / 100,  // Normalizar\n    total_score: rec.total_score,\n    explanation: rec.explanation\n}));\n\n// Respuesta completa\nmsg.payload = {\n    refugee: savedRefugee,\n    assignment: {\n        id: assignment.id,\n        shelter_id: topRec.shelter_id,\n        shelter_name: topRec.shelter_name,\n        priority_score: topRec.total_score,\n        confidence_score: confidenceNormalized,\n        explanation: topRec.explanation,\n        match_details: topRec.match_details,\n        status: assignment.status,\n        assigned_at: assignment.assigned_at,\n        alternative_shelters: alternatives\n    }\n};\n\nmsg.statusCode = 201;\n\n// Limpiar variables de flujo\nflow.set('tempRefugeeData', null);\nflow.set('savedRefugee', null);\nflow.set('aiResponse', null);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 340,
        "wires": [
            [
                "final_http_response",
                "41aa3f26b3b03799"
            ]
        ]
    },
    {
        "id": "final_http_response",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Respuesta HTTP",
        "statusCode": "",
        "headers": {},
        "x": 1010,
        "y": 340,
        "wires": []
    },
    {
        "id": "get_ai_recommendation",
        "type": "http in",
        "z": "tab_ai_integration",
        "name": "GET /api/ai/recommend/:refugeeId",
        "url": "/api/ai/recommend/:refugeeId",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 420,
        "wires": [
            [
                "prepare_refugee_query"
            ]
        ]
    },
    {
        "id": "prepare_refugee_query",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Preparar query",
        "func": "const refugeeId = msg.req.params.refugeeId;\nmsg.params = [refugeeId];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 420,
        "wires": [
            [
                "fetch_refugee_for_recommendation"
            ]
        ]
    },
    {
        "id": "fetch_refugee_for_recommendation",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "Obtener refugiado",
        "query": "SELECT * FROM refugees WHERE id = $1",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 590,
        "y": 420,
        "wires": [
            [
                "check_refugee_exists"
            ]
        ]
    },
    {
        "id": "check_refugee_exists",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Verificar refugiado",
        "func": "if (!msg.payload || msg.payload.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: 'Refugiado no encontrado' };\n    return [null, msg];\n}\n\nconst refugee = msg.payload[0];\n\n// Calcular family_size, has_children, children_count\nlet family_size = 1;\nlet has_children = false;\nlet children_count = 0;\n\nif (refugee.family_id) {\n    family_size = 1;\n}\n\n// Preparar payload para el servicio de IA\nmsg.payload = {\n    first_name: refugee.first_name,\n    last_name: refugee.last_name,\n    age: refugee.age,\n    gender: refugee.gender,\n    nationality: refugee.nationality,\n    languages_spoken: refugee.languages_spoken,\n    medical_conditions: refugee.medical_conditions,\n    has_disability: refugee.has_disability,\n    vulnerability_score: refugee.vulnerability_score,\n    special_needs: refugee.special_needs,\n    family_id: refugee.family_id,\n    family_size: family_size,\n    has_children: has_children,\n    children_count: children_count\n};\n\n// Guardar refugee original para la respuesta\nflow.set('originalRefugee', refugee);\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 420,
        "wires": [
            [
                "call_ai_for_recommendation"
            ],
            []
        ]
    },
    {
        "id": "call_ai_for_recommendation",
        "type": "http request",
        "z": "tab_ai_integration",
        "name": "Obtener recomendación IA",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://shelterai-ai-service:8000/api/recommend",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Content-Type",
                "keyValue": "",
                "valueType": "application/json",
                "valueValue": ""
            }
        ],
        "x": 1050,
        "y": 420,
        "wires": [
            [
                "format_recommendation_response"
            ]
        ]
    },
    {
        "id": "format_recommendation_response",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Formatear respuesta",
        "func": "// Obtener los datos del refugiado original\nconst originalRefugee = flow.get('originalRefugee');\nconst aiResponse = msg.payload;\n\nif (!aiResponse || !aiResponse.recommendations || aiResponse.recommendations.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: 'No se encontraron recomendaciones de refugios' };\n    return msg;\n}\n\n// Formatear respuesta en el formato que espera Flutter (RecommendationResponse)\nconst recommendations = aiResponse.recommendations.map(rec => ({\n    shelter_id: rec.shelter_id,\n    shelter_name: rec.shelter_name,\n    address: rec.address || '',\n    compatibility_score: rec.compatibility_score || 0,\n    priority_score: rec.total_score || 0,\n    max_capacity: rec.max_capacity || 0,\n    current_occupancy: rec.current_occupancy || 0,\n    available_space: rec.available_space || 0,\n    occupancy_rate: rec.occupancy_rate || 0,\n    has_medical_facilities: rec.has_medical_facilities === true,\n    has_childcare: rec.has_childcare === true,\n    has_disability_access: rec.has_disability_access === true,\n    languages_spoken: rec.languages_spoken || '',\n    shelter_type: rec.shelter_type || '',\n    services_offered: rec.services_offered || '',\n    explanation: rec.explanation || ''\n}));\n\nmsg.payload = {\n    refugee_name: (originalRefugee.first_name || '') + ' ' + (originalRefugee.last_name || ''),\n    refugee_age: originalRefugee.age || 0,\n    refugee_nationality: originalRefugee.nationality || '',\n    refugee_family_size: 1,\n    refugee_gender: originalRefugee.gender || '',\n    recommendations: recommendations,\n    cluster_id: aiResponse.cluster_id || 0,\n    cluster_label: aiResponse.cluster_label || 'No etiqueta',\n    vulnerability_level: aiResponse.vulnerability_level || 'unknown',\n    total_shelters_analyzed: aiResponse.total_shelters_analyzed || 0,\n    ml_model_version: aiResponse.model_version || '1.0'\n};\n\nmsg.statusCode = 200;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 420,
        "wires": [
            [
                "send_recommendation_response"
            ]
        ]
    },
    {
        "id": "send_recommendation_response",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Enviar respuesta",
        "statusCode": "",
        "headers": {},
        "x": 1540,
        "y": 420,
        "wires": []
    },
    {
        "id": "41aa3f26b3b03799",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Preparar Correo",
        "func": "// 1. Extraemos los datos que generó el nodo anterior\n// Usamos \"|| {}\" para evitar errores si algo viene vacío\nconst data = msg.payload || {};\nconst refugee = data.refugee || {};\nconst assignment = data.assignment || {};\n\n// 2. Extraemos el email del refugiado\nconst emailDestino = refugee.email;\n\n// SEGURIDAD: Si el refugiado no tiene email, cortamos aquí.\n// Usamos 'return null' para que el flujo NO siga hacia el nodo de Gmail y no dé error.\nif (!emailDestino) {\n  node.warn(\"Asignación completada, pero no se envió email (Falta correo del refugiado)\");\n  return null;\n}\n\n// 3. Preparamos variables para que el texto quede bonito\n// Usamos .trim() para quitar espacios sobrantes en el nombre\nconst nombreCompleto = `${refugee.first_name || ''} ${refugee.last_name || ''}`.trim() || 'Refugiado';\nconst nombreRefugio = assignment.shelter_name || 'Centro asignado';\nconst explicacion = assignment.explanation || 'Asignación basada en disponibilidad y necesidades.';\nconst fecha = new Date().toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });\n\n// 4. Configuración para el nodo de Email (node-red-node-email)\nmsg.to = emailDestino;\nmsg.topic = `✅ Asignación Confirmada: ${nombreRefugio} - ShelterAI`;\n\n// 5. Cuerpo en Texto Plano (Por si el móvil del usuario no lee HTML)\nmsg.payload = `Hola ${nombreCompleto},\n\nTe confirmamos que el sistema ShelterAI te ha asignado plaza en: ${nombreRefugio}.\n\nMotivo de la selección: ${explicacion}\n\nPor favor, acude lo antes posible.\nFecha: ${fecha}\n\nAtentamente,\nEquipo ShelterAI`;\n\n// 6. Cuerpo en HTML (Diseño profesional con colores y tarjetas)\nmsg.html = `\n<div style=\"font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; max-width: 600px; margin: 0 auto; border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.1);\">\n    \n    <div style=\"background-color: #2E7D32; padding: 20px; text-align: center;\">\n        <h2 style=\"color: white; margin: 0; font-size: 24px;\">¡Asignación Confirmada!</h2>\n    </div>\n\n    <div style=\"padding: 30px; background-color: #ffffff;\">\n        <p style=\"font-size: 16px; color: #333;\">Hola <strong>${nombreCompleto}</strong>,</p>\n        \n        <p style=\"font-size: 16px; color: #555;\">Hemos encontrado el refugio que mejor se adapta a tus necesidades actuales.</p>\n\n        <div style=\"background-color: #f1f8e9; border-left: 5px solid #2E7D32; padding: 20px; margin: 25px 0; border-radius: 4px;\">\n            <h3 style=\"margin-top: 0; color: #1B5E20; font-size: 20px;\">📍 ${nombreRefugio}</h3>\n            \n            <p style=\"margin-bottom: 5px;\"><strong>¿Por qué este refugio?</strong></p>\n            <p style=\"margin-top: 0; color: #444; font-style: italic;\">\"${explicacion}\"</p>\n            \n            <hr style=\"border: 0; border-top: 1px solid #dcedc8; margin: 15px 0;\">\n            \n            <p style=\"margin: 0; font-size: 14px; color: #555;\"><strong>Fecha de asignación:</strong> ${fecha}</p>\n        </div>\n\n        <p style=\"font-size: 14px; color: #777;\">Por favor, presenta este correo al llegar al centro para agilizar tu entrada.</p>\n    </div>\n\n    <div style=\"background-color: #f5f5f5; padding: 15px; text-align: center; font-size: 12px; color: #999;\">\n        © 2026 ShelterAI Project - Ayuda Humanitaria Inteligente\n    </div>\n</div>\n`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 280,
        "wires": [
            [
                "ad8e96e2588a39af"
            ]
        ]
    },
    {
        "id": "ad8e96e2588a39af",
        "type": "e-mail",
        "z": "tab_ai_integration",
        "server": "smtp.gmail.com",
        "port": "587",
        "authtype": "BASIC",
        "saslformat": true,
        "token": "oauth2Response.access_token",
        "secure": false,
        "tls": true,
        "name": "",
        "dname": "",
        "x": 1190,
        "y": 280,
        "wires": []
    },
    {
        "id": "assign_shelter_http_in",
        "type": "http in",
        "z": "tab_ai_integration",
        "name": "POST /api/ai/assign-shelter",
        "url": "/api/ai/assign-shelter",
        "method": "post",
        "upload": false,
        "x": 150,
        "y": 800,
        "wires": [
            [
                "assign_shelter_prepare"
            ]
        ]
    },
    {
        "id": "assign_shelter_function",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Prepare Update Query",
        "func": "// Desestructuramos los datos de entrada\nconst { refugee_id, shelter_id, recommendation_log_id } = msg.payload;\n\n// 1. Validación\nif (!refugee_id || !shelter_id) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Error: refugee_id y shelter_id son requeridos' };\n    // Salimos por el Output 2 (Error)\n    return [null, msg];\n}\n\n// 2. Guardar datos de contexto en el mensaje (Más seguro que flow.set)\n// Creamos una propiedad personalizada para que estos datos viajen al siguiente nodo\n// sin perderse tras la consulta SQL.\nmsg.assignmentContext = {\n    refugee_id: refugee_id,\n    shelter_id: shelter_id,\n    recommendation_log_id: recommendation_log_id\n};\n\n// 3. Query SQL\n// Usamos msg.query para ser consistentes\nmsg.query = `\n    UPDATE refugee \n    SET assigned_shelter_id = $1, \n        status = 'assigned',\n        updated_at = NOW()\n    WHERE id = $2\n    RETURNING id, first_name, last_name, assigned_shelter_id\n`;\n\n// 4. Parámetros\n// IMPORTANTE: Los parámetros van en msg.params, no en msg.payload\nmsg.params = [shelter_id, refugee_id];\n\n// Limpiamos payload para el nodo SQL\nmsg.payload = null;\n\nconsole.log(`[ASSIGN] Assigning shelter ${shelter_id} to refugee ${refugee_id}`);\n\n// Salimos por el Output 1 (Éxito)\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 520,
        "wires": [
            [],
            [
                "assign_shelter_http_response"
            ]
        ]
    },
    {
        "id": "assign_shelter_http_response",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Success Response",
        "statusCode": "200",
        "headers": {},
        "x": 1650,
        "y": 740,
        "wires": []
    },
    {
        "id": "assign_shelter_prepare",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Prepare Update",
        "func": "let body = msg.payload;\nif (typeof body === 'string') {\n  try { body = JSON.parse(body); } catch (e) { body = {}; }\n}\n\nconst rawRefugeeId = body.refugee_id;\nconst rawShelterId = body.shelter_id;\n\nconst refugee_id = Number(rawRefugeeId);\nconst shelter_id = Number(rawShelterId);\n\nif (!Number.isInteger(refugee_id) || !Number.isInteger(shelter_id) || refugee_id <= 0 || shelter_id <= 0) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'refugee_id y shelter_id deben ser enteros > 0' };\n    return [null, msg];\n}\n\n// Preparar query para actualizar refugiado\nmsg.query = `UPDATE refugee \n             SET assigned_shelter_id = $1, \n                 status = 'assigned',\n                 updated_at = NOW()\n             WHERE id = $2\n             RETURNING id, assigned_shelter_id, status`;\n\nmsg.params = [shelter_id, refugee_id];\nmsg.payload = null;\n\nconsole.log('[ASSIGN] Updating refugee', refugee_id, 'with shelter', shelter_id);\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 840,
        "wires": [
            [
                "assign_shelter_query"
            ],
            [
                "assign_shelter_error"
            ]
        ]
    },
    {
        "id": "assign_shelter_query",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "Update Refugee",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 650,
        "y": 800,
        "wires": [
            [
                "assign_shelter_response"
            ]
        ]
    },
    {
        "id": "assign_shelter_response",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Format Response",
        "func": "// 1. Validar que la asignación del refugiado funcionó (viene del nodo anterior)\nif (!msg.payload || msg.payload.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: 'Error: No se encontró el refugiado para actualizar.' };\n    return [null, msg]; // Salida de error\n}\n\nconst result = msg.payload[0];\nconst shelterId = result.assigned_shelter_id;\n\n// 2. GUARDAR DATOS EN LA \"MALETA\"\n// Como vamos a ejecutar otra query ahora, el msg.payload se va a borrar.\n// Guardamos los datos del refugiado aquí para usarlos al final del todo.\nmsg.datosRefugiado = {\n    refugee_id: result.id,\n    assigned_shelter_id: shelterId,\n    status: result.status\n};\n\n// 3. Preparar la Query para RESTAR AFORO (Update Shelter)\n// Restamos 1 al espacio disponible\nmsg.query = `\n    UPDATE shelters \n    SET available_space = available_space - 1,\n        updated_at = NOW()\n    WHERE id = $1\n`;\n\nmsg.params = [shelterId];\n\n// Limpiamos payload para el siguiente nodo SQL\nmsg.payload = null;\n\nconsole.log(`[LOGIC] Preparando resta de aforo para Shelter ID: ${shelterId}`);\n\n// Pasamos al siguiente nodo (Postgres)\nreturn [msg, null];",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 800,
        "wires": [
            [
                "95cffb18972600be"
            ]
        ]
    },
    {
        "id": "assign_shelter_error",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Error Response",
        "statusCode": "",
        "x": 660,
        "y": 900,
        "wires": []
    },
    {
        "id": "95cffb18972600be",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": 1,
        "outputs": 1,
        "x": 1130,
        "y": 800,
        "wires": [
            [
                "aca51ab62bc08951"
            ]
        ]
    },
    {
        "id": "aca51ab62bc08951",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Format Final Response",
        "func": "// Recuperamos los datos que guardamos en la \"maleta\" en el Paso A\nconst datos = msg.datosRefugiado;\n\n// Preparamos la respuesta final bonita para Flutter\nmsg.statusCode = 200;\nmsg.payload = {\n    success: true,\n    refugee_id: datos.refugee_id,\n    assigned_shelter_id: datos.assigned_shelter_id,\n    status: datos.status,\n    message: 'Proceso completo: Refugiado asignado y aforo del refugio actualizado.'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 800,
        "wires": [
            [
                "assign_shelter_http_response"
            ]
        ]
    },
    {
        "id": "login_validation",
        "type": "function",
        "z": "tab_login",
        "name": "Validar y Preparar",
        "func": "// Function: Validar y Preparar Login\n\n// 1. Validar que llegue algo\nif (!msg.payload || typeof msg.payload !== 'object') {\n  // Usamos node.error para activar el nodo Catch si lo tienes configurado\n  // O devolvemos el error directo si vas al HTTP Response.\n  msg.statusCode = 400;\n  msg.payload = { success: false, message: 'Datos inválidos' };\n  \n  // OPCIÓN A: Si usas Catch, descomenta la siguiente línea y pon return null\n  // node.error(\"Datos inválidos\", msg); return null; \n  \n  // OPCIÓN B (La actual): Devolver msg PERO asegúrate de no conectarlo al nodo Postgres\n  return msg; \n}\n\n// 2. Extracción Inteligente + LIMPIEZA (.trim())\n// Esto elimina espacios en blanco al inicio o final (súper común en móviles)\nlet identifier = msg.payload.identifier || msg.payload.email || msg.payload.username || msg.payload.phone_number;\n\nif (typeof identifier === 'string') {\n    identifier = identifier.trim();\n}\n\nconst password = msg.payload.password;\n\n// 3. Validación de campos requeridos\nif (!identifier || !password || typeof password !== 'string' || password.length === 0) {\n  msg.statusCode = 400;\n  msg.payload = {\n    success: false,\n    message: 'Error: Debes introducir usuario/email/teléfono y contraseña.'\n  };\n  \n  // Si validación falla, cortamos aquí.\n  // IMPORTANTE: Conecta una salida de este nodo directa al HTTP Response para estos casos,\n  // o usa node.error() como vimos antes.\n  return msg;\n}\n\n// 4. Guardar password para verificar después (Bcrypt)\nmsg.passwordToVerify = password;\n\n// 5. Query Multiuso\n// Buscamos coincidencia en CUALQUIERA de las 3 columnas\nmsg.query = 'SELECT id, email, username, password, first_name, last_name, role FROM users WHERE email = $1 OR username = $1 OR phone_number = $1';\nmsg.params = [identifier];\n\n// 6. Limpieza para seguridad\nmsg.payload = null;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 100,
        "wires": [
            [
                "login_db_query"
            ]
        ]
    },
    {
        "id": "login_db_query",
        "type": "postgresql",
        "z": "tab_login",
        "name": "Consultar Usuario",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 650,
        "y": 100,
        "wires": [
            [
                "login_verify"
            ]
        ]
    },
    {
        "id": "login_verify",
        "type": "function",
        "z": "tab_login",
        "name": "Verificar y Responder",
        "func": "// El nodo PostgreSQL devuelve un array con las filas insertadas\nvar filas = msg.payload;\n\ntry {\n  if (filas && filas.length > 0) {\n    var usuarioNuevo = filas[0];\n\n    // ÉXITO: Construimos la respuesta 201\n    msg.statusCode = 201;\n    msg.payload = {\n      \"success\": true,\n      \"user_id\": usuarioNuevo.id,\n      \"first_name\": usuarioNuevo.first_name,\n      \"last_name\": usuarioNuevo.last_name,\n      \"username\": usuarioNuevo.username,\n      \"email\": usuarioNuevo.email,\n      \"role\": usuarioNuevo.role,\n      \"token\": \"simulated_token_\" + Date.now()\n    };\n\n    // Devolvemos el mensaje por la salida normal\n    return msg;\n\n  } else {\n    // ERROR: No hay filas. \n    // Aquí es donde FORZAMOS la llamada al nodo Catch.\n\n    var errorMsg = \"No se pudo recuperar el usuario creado (la base de datos no devolvió filas)\";\n\n    // 1. Preparamos el mensaje de error para el Catch\n    // (El nodo Catch recibirá esto en msg.error)\n    var err = new Error(errorMsg);\n\n    // 2. Avisamos a Node-RED de que ha habido un error.\n    // El segundo parámetro 'msg' se pasa al nodo Catch para que no pierdas los datos.\n    node.error(err, msg);\n\n    // 3. Devolvemos null para CORTAR el flujo normal.\n    // Así no sigue hacia el nodo HTTP Response de éxito, sino que salta al Catch.\n    return null;\n  }\n} catch (e) {\n  // Si hay un error de código imprevisto (ej: variable undefined), también lo mandamos al Catch\n  node.error(e, msg);\n  return null;\n}// El nodo PostgreSQL devuelve un array con las filas insertadas\n// gracias al \"RETURNING\" que pusimos en la query.\nvar filas = msg.payload;\n\nif (filas && filas.length > 0) {\n  var usuarioNuevo = filas[0];\n\n  // Construimos la respuesta EXACTAMENTE igual que en el Login\n  // Así el frontend puede guardar el token y entrar directamente.\n  msg.statusCode = 201; // 201 Created (es lo correcto para registros)\n  msg.payload = {\n    \"success\": true,\n    \"user_id\": usuarioNuevo.id,\n    \"first_name\": usuarioNuevo.first_name,\n    \"last_name\": usuarioNuevo.last_name,\n    \"username\": usuarioNuevo.username,\n    \"email\": usuarioNuevo.email,\n    \"role\": usuarioNuevo.role, // Será 'refugee'\n    \"token\": \"simulated_token_\" + Date.now() // Token para que entre directo\n  };\n} else {\n  // Si por lo que sea no devuelve filas (raro si no dio error antes)\n  msg.statusCode = 500;\n  msg.payload = { \"error\": \"No se pudo recuperar el usuario creado\" };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 100,
        "wires": [
            [
                "login_http_response"
            ]
        ]
    },
    {
        "id": "login_http_response",
        "type": "http response",
        "z": "tab_login",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1110,
        "y": 100,
        "wires": []
    },
    {
        "id": "22c0c426bf478142",
        "type": "http in",
        "z": "tab_login",
        "name": "POST /api/register",
        "url": "/api/register",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 300,
        "wires": [
            [
                "e2216cfe7183366c"
            ]
        ]
    },
    {
        "id": "e2216cfe7183366c",
        "type": "function",
        "z": "tab_login",
        "name": "Validar y Preparar",
        "func": "// 1. Extraemos los datos del Frontend\n// Flutter envía: { name: \"Juan Pérez\", email: \"...\", password: \"...\" }\nvar payload = msg.payload || {};\n\nvar rawName = payload.name || \"\";\nvar email = payload.email;\nvar password = payload.password;\n\n// 2. Validación de seguridad básica\nif (!email || !password || !rawName) {\n    msg.statusCode = 400;\n    msg.payload = { error: \"Faltan datos obligatorios: Nombre, Email y Contraseña\" };\n    // Cortamos el flujo para no intentar insertar nada\n    return [null, msg];\n}\n\n// 3. TRANSFORMACIÓN DE DATOS (Adaptación a tu Base de Datos)\n\n// A) Generar Username Automático\n// La tabla pide 'username' UNIQUE, pero el form de trabajador no lo pide.\n// Lo creamos usando la parte anterior al @ del email.\n// Ej: juan@ong.org -> username: juan\nvar autoUsername = email.split('@')[0];\n\n// B) Separar Nombre y Apellido\n// La tabla tiene 'first_name' y 'last_name', pero Flutter envía 'name' junto.\nvar parts = rawName.trim().split(\" \");\nvar firstName = parts[0]; // La primera palabra\nvar lastName = parts.slice(1).join(\" \") || \"\"; // El resto, o vacío si no tiene apellido\n\n// 4. Query SQL\n// Insertamos en: first_name, last_name, username, email, password, role.\n// role lo fijamos a 'worker'.\nmsg.query = `\n    INSERT INTO users (\n        first_name, \n        last_name, \n        username, \n        email, \n        password, \n        role,\n        phone_number\n    ) \n    VALUES ($1, $2, $3, $4, $5, 'worker', NULL) \n    RETURNING id, username, email, role, first_name, last_name\n`;\n\n// 5. Parámetros (En el orden exacto de los $1, $2...)\nmsg.params = [\n    firstName,     // $1\n    lastName,      // $2\n    autoUsername,  // $3 (Generado)\n    email,         // $4\n    password,      // $5\n];\n\n// 6. Limpieza\nmsg.payload = {};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 300,
        "wires": [
            [
                "78899a30e92aecbe"
            ]
        ]
    },
    {
        "id": "78899a30e92aecbe",
        "type": "postgresql",
        "z": "tab_login",
        "name": "Consultar Usuario",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 640,
        "y": 300,
        "wires": [
            [
                "5e41704bfdb79d59"
            ]
        ]
    },
    {
        "id": "5e41704bfdb79d59",
        "type": "function",
        "z": "tab_login",
        "name": "Verificar y Responder",
        "func": "// El nodo PostgreSQL devuelve un array con las filas insertadas\nvar filas = msg.payload;\n\ntry {\n    if (filas && filas.length > 0) {\n        var usuarioNuevo = filas[0];\n\n        // ÉXITO: Construimos la respuesta 201\n        msg.statusCode = 201;\n        msg.payload = {\n            \"success\": true,\n            \"user_id\": usuarioNuevo.id,\n            \"name\": usuarioNuevo.full_name,\n            \"email\": usuarioNuevo.email,\n            \"role\": usuarioNuevo.role,\n            \"token\": \"simulated_token_\" + Date.now()\n        };\n\n        // Devolvemos el mensaje por la salida normal\n        return msg;\n\n    } else {\n        // ERROR: No hay filas. \n        // Aquí es donde FORZAMOS la llamada al nodo Catch.\n\n        var errorMsg = \"No se pudo recuperar el usuario creado (la base de datos no devolvió filas)\";\n\n        // 1. Preparamos el mensaje de error para el Catch\n        // (El nodo Catch recibirá esto en msg.error)\n        var err = new Error(errorMsg);\n\n        // 2. Avisamos a Node-RED de que ha habido un error.\n        // El segundo parámetro 'msg' se pasa al nodo Catch para que no pierdas los datos.\n        node.error(err, msg);\n\n        // 3. Devolvemos null para CORTAR el flujo normal.\n        // Así no sigue hacia el nodo HTTP Response de éxito, sino que salta al Catch.\n        return null;\n    }\n} catch (e) {\n    // Si hay un error de código imprevisto (ej: variable undefined), también lo mandamos al Catch\n    node.error(e, msg);\n    return null;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1020,
        "y": 300,
        "wires": [
            [
                "cb383e10764124f8"
            ]
        ]
    },
    {
        "id": "cb383e10764124f8",
        "type": "http response",
        "z": "tab_login",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1250,
        "y": 300,
        "wires": []
    },
    {
        "id": "63d32f953f6537d2",
        "type": "function",
        "z": "tab_login",
        "name": "Preparar Correo",
        "func": "// Function: Preparar Alerta de Login\n\n// En el flujo de login, el payload suele traer el usuario tras la verificación\nconst user = msg.payload;\nconst email = user.email;\n\n// Validación de seguridad\nif (!email) {\n    node.warn('Login Email: No hay email en el payload');\n    return null; // Detenemos el flujo para no romper el nodo Gmail\n}\n\nconst fullName = user.name || 'Usuario';\nconst time = new Date().toLocaleTimeString();\nconst date = new Date().toLocaleDateString();\n\n// Configuración para node-red-node-email\nmsg.to = email;\nmsg.topic = 'Alerta de Seguridad: Nuevo inicio de sesión - ShelterAI';\n\n// Cuerpo Texto (Fallback)\nmsg.payload = `Hola ${fullName},\nSe ha detectado un nuevo inicio de sesión en tu cuenta de ShelterAI.\nFecha: ${date}\nHora: ${time}\n\nSi no has sido tú, contacta con un administrador inmediatamente.`;\n\n// Cuerpo HTML (Bonito)\nmsg.html = `\n<h3>Hola, ${fullName}</h3>\n<p>Se ha detectado un nuevo acceso a tu cuenta.</p>\n<div style=\"background-color: #fff3cd; color: #856404; padding: 15px; border-radius: 5px; border: 1px solid #ffeeba;\">\n  <strong>Nuevo Inicio de Sesión</strong><br>\n  <ul>\n    <li><strong>Fecha:</strong> ${date}</li>\n    <li><strong>Hora:</strong> ${time}</li>\n  </ul>\n</div>\n<p>Si has sido tú, puedes ignorar este mensaje.</p>\n<p style=\"font-size: 12px; color: #666;\">Equipo de Seguridad ShelterAI</p>\n`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 200,
        "wires": [
            [
                "dc46be29a6f0c76e"
            ]
        ]
    },
    {
        "id": "91b170f70235ff3c",
        "type": "http in",
        "z": "tab_login",
        "name": "POST /api/login",
        "url": "/api/login",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 100,
        "wires": [
            [
                "login_validation"
            ]
        ]
    },
    {
        "id": "dc46be29a6f0c76e",
        "type": "e-mail",
        "z": "tab_login",
        "server": "smtp.gmail.com",
        "port": "587",
        "authtype": "BASIC",
        "saslformat": true,
        "token": "oauth2Response.access_token",
        "secure": false,
        "tls": true,
        "name": "",
        "dname": "",
        "x": 1290,
        "y": 200,
        "wires": []
    },
    {
        "id": "a6799ab6ebc69493",
        "type": "http in",
        "z": "tab_login",
        "name": "POST /api/register-refugee",
        "url": "/api/register-refugee",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 400,
        "wires": [
            [
                "9e799a512b71a198"
            ]
        ]
    },
    {
        "id": "9e799a512b71a198",
        "type": "function",
        "z": "tab_login",
        "name": "Validar y Preparar",
        "func": "// 1. Extraemos y limpiamos los datos\nvar payload = msg.payload || {};\n\n// Campos obligatorios (según tu lógica de negocio)\nvar firstName = payload.first_name;\nvar lastName = payload.last_name || \"\"; // Puede estar vacío\nvar username = payload.username;\nvar password = payload.password;\n\n// Generamos full_name automáticamente para que la BD esté ordenada\nvar fullName = (firstName + \" \" + lastName).trim();\n\n// Campos Opcionales (convertimos vacíos a null para Postgres)\nvar email = payload.email || null;\nvar phone = payload.phone_number || null;\nvar address = payload.address || null;\n\n// Convertir edad a entero (seguridad)\nvar age = (payload.age && !isNaN(payload.age)) ? parseInt(payload.age) : null;\nvar gender = payload.gender || null;\n\n// 2. Validación de Seguridad (Solo lo estrictamente obligatorio)\n// Quitamos address y age de aquí porque en el formulario eran opcionales\nif (!username || !password || !firstName) {\n    msg.statusCode = 400;\n    msg.payload = { \n        success: false,\n        error: \"Faltan datos obligatorios: Usuario, Contraseña o Nombre.\" \n    };\n    // Importante: Usamos node.error o return null para no activar el nodo SQL\n    return [null, msg]; \n}\n\n// 3. Query SQL (Solo columnas que existen en tabla users)\nmsg.query = `\n    INSERT INTO users (\n        first_name, last_name, \n        username, email, password, \n        phone_number, \n        role\n    ) \n    VALUES ($1, $2, $3, $4, $5, $6, 'refugee') \n    RETURNING id, first_name, last_name, username, email, role\n`;\n\n// 4. Parámetros (6 valores)\nmsg.params = [\n    firstName,  // $1\n    lastName,   // $2\n    username,   // $3\n    email,      // $4\n    password,   // $5\n    phone       // $6\n];\n\n// 5. Limpieza\nmsg.payload = null;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 400,
        "wires": [
            [
                "edbf42abf00626cf"
            ]
        ]
    },
    {
        "id": "edbf42abf00626cf",
        "type": "postgresql",
        "z": "tab_login",
        "name": "Consultar Usuario",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 650,
        "y": 400,
        "wires": [
            [
                "5e41704bfdb79d59"
            ]
        ]
    },
    {
        "id": "69a2ff37382fd8d7",
        "type": "catch",
        "z": "tab_login",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 660,
        "y": 160,
        "wires": [
            [
                "30cff48a648b2fb3"
            ]
        ]
    },
    {
        "id": "30cff48a648b2fb3",
        "type": "debug",
        "z": "tab_login",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 160,
        "wires": []
    }
]