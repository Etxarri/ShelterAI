[
    {
        "id": "tab_shelters",
        "type": "tab",
        "label": "Shelters API",
        "disabled": false,
        "info": "API REST para gesti√≥n de albergues"
    },
    {
        "id": "tab_refugees",
        "type": "tab",
        "label": "Refugees API",
        "disabled": false,
        "info": "API REST para gesti√≥n de refugiados"
    },
    {
        "id": "tab_assignments",
        "type": "tab",
        "label": "Assignments API",
        "disabled": false,
        "info": "API REST para gesti√≥n de asignaciones"
    },
    {
        "id": "tab_ai_integration",
        "type": "tab",
        "label": "AI Integration",
        "disabled": false,
        "info": "Integraci√≥n con el servicio de IA para asignaci√≥n autom√°tica de refugios"
    },
    {
        "id": "tab_login",
        "type": "tab",
        "label": "Auth API",
        "disabled": false,
        "info": "API para autenticaci√≥n y login"
    },
    {
        "id": "301245f94e1239d9",
        "type": "postgreSQLConfig",
        "name": "ShelterAI DB",
        "host": "postgres",
        "hostFieldType": "str",
        "port": 5432,
        "portFieldType": "num",
        "database": "shelterai",
        "databaseFieldType": "str",
        "ssl": "false",
        "sslFieldType": "bool",
        "applicationName": "",
        "applicationNameType": "str",
        "max": 10,
        "maxFieldType": "num",
        "idle": 1000,
        "idleFieldType": "num",
        "connectionTimeout": 10000,
        "connectionTimeoutFieldType": "num",
        "user": "root",
        "userFieldType": "str",
        "password": "root",
        "passwordFieldType": "str"
    },
    {
        "id": "shelter_get_all",
        "type": "http in",
        "z": "tab_shelters",
        "name": "GET /api/shelters",
        "url": "/api/shelters",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 260,
        "wires": [
            [
                "shelter_get_all_query"
            ]
        ]
    },
    {
        "id": "shelter_get_all_query",
        "type": "postgresql",
        "z": "tab_shelters",
        "name": "Query All Shelters",
        "query": "SELECT * FROM shelters ORDER BY id",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 370,
        "y": 260,
        "wires": [
            [
                "shelter_response"
            ]
        ]
    },
    {
        "id": "shelter_get_by_id",
        "type": "http in",
        "z": "tab_shelters",
        "name": "GET /api/shelters/:id",
        "url": "/api/shelters/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 320,
        "wires": [
            [
                "shelter_get_by_id_prepare"
            ]
        ]
    },
    {
        "id": "shelter_get_by_id_prepare",
        "type": "function",
        "z": "tab_shelters",
        "name": "Prepare Query",
        "func": "msg.queryParameters = [parseInt(msg.req.params.id)];\nmsg.query = \"SELECT * FROM shelters WHERE id = $1\";\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 320,
        "wires": [
            [
                "shelter_get_by_id_query"
            ]
        ]
    },
    {
        "id": "shelter_get_by_id_query",
        "type": "postgresql",
        "z": "tab_shelters",
        "name": "Query Shelter",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 580,
        "y": 320,
        "wires": [
            [
                "shelter_single_response"
            ]
        ]
    },
    {
        "id": "shelter_get_available",
        "type": "http in",
        "z": "tab_shelters",
        "name": "GET /api/shelters/available",
        "url": "/api/shelters/available",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 200,
        "wires": [
            [
                "shelter_get_available_query"
            ]
        ]
    },
    {
        "id": "shelter_get_available_query",
        "type": "postgresql",
        "z": "tab_shelters",
        "name": "Query Available",
        "query": "SELECT * FROM shelters WHERE current_occupancy < max_capacity ORDER BY id",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 420,
        "y": 200,
        "wires": [
            [
                "shelter_response"
            ]
        ]
    },
    {
        "id": "shelter_response",
        "type": "function",
        "z": "tab_shelters",
        "name": "Format Response",
        "func": "msg.statusCode = 200;\nmsg.payload = msg.payload || [];\nreturn msg;",
        "outputs": 1,
        "x": 630,
        "y": 240,
        "wires": [
            [
                "shelter_http_response"
            ]
        ]
    },
    {
        "id": "shelter_single_response",
        "type": "function",
        "z": "tab_shelters",
        "name": "Format Single",
        "func": "if (msg.payload && msg.payload.length > 0) {\n    msg.statusCode = 200;\n    msg.payload = msg.payload[0];\n} else {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Shelter not found\" };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 320,
        "wires": [
            [
                "shelter_http_response"
            ]
        ]
    },
    {
        "id": "shelter_http_response",
        "type": "http response",
        "z": "tab_shelters",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1000,
        "y": 260,
        "wires": []
    },
    {
        "id": "refugee_get_all",
        "type": "http in",
        "z": "tab_refugees",
        "name": "GET /api/refugees",
        "url": "/api/refugees",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 260,
        "wires": [
            [
                "refugee_get_all_query"
            ]
        ]
    },
    {
        "id": "refugee_get_all_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "name": "Query All Refugees",
        "query": "SELECT * FROM refugees WHERE assigned_shelter_id IS NULL OR status != 'assigned' ORDER BY id",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 390,
        "y": 260,
        "wires": [
            [
                "refugee_response"
            ]
        ]
    },
    {
        "id": "refugee_get_assigned",
        "type": "http in",
        "z": "tab_refugees",
        "name": "GET /api/refugees/assigned",
        "url": "/api/refugees/assigned",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 200,
        "wires": [
            [
                "refugee_get_assigned_query"
            ]
        ]
    },
    {
        "id": "refugee_get_assigned_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "name": "Query Assigned Refugees",
        "query": "SELECT r.*, s.name as shelter_name, s.address as shelter_address FROM refugees r LEFT JOIN shelters s ON r.assigned_shelter_id = s.id WHERE r.assigned_shelter_id IS NOT NULL AND r.status = 'assigned' ORDER BY r.updated_at DESC",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 470,
        "y": 200,
        "wires": [
            [
                "refugee_response"
            ]
        ]
    },
    {
        "id": "refugee_get_by_id",
        "type": "http in",
        "z": "tab_refugees",
        "name": "GET /api/refugees/:id",
        "url": "/api/refugees/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 320,
        "wires": [
            [
                "refugee_get_by_id_prepare"
            ]
        ]
    },
    {
        "id": "refugee_get_by_id_prepare",
        "type": "function",
        "z": "tab_refugees",
        "name": "Prepare Query",
        "func": "const data = msg.payload;\n\nmsg.query = `INSERT INTO refugees (first_name, last_name, age, gender, nationality, languages_spoken, email, family_size, has_children, children_count, medical_conditions, requires_medical_facilities, has_disability, special_needs, vulnerability_score, status, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, 'new', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) RETURNING *`;\n\nmsg.params = [\n    data.first_name, \n    data.last_name, \n    data.age, \n    data.gender,\n    data.nationality, \n    data.languages_spoken || null, \n    data.email || null,\n    data.family_size || 1,\n    data.has_children || false,\n    data.children_count || 0,\n    data.medical_conditions || null,\n    data.requires_medical_facilities || false,\n    data.has_disability || false,\n    data.special_needs || null, \n    data.vulnerability_score || 0\n];\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 320,
        "wires": [
            [
                "refugee_get_by_id_query"
            ]
        ]
    },
    {
        "id": "refugee_get_by_id_query",
        "type": "postgresql",
        "z": "tab_refugees",
        "name": "Query Refugee",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 320,
        "wires": [
            [
                "refugee_single_response"
            ]
        ]
    },
    {
        "id": "refugee_response",
        "type": "function",
        "z": "tab_refugees",
        "name": "Format Response",
        "func": "msg.statusCode = 200;\nmsg.payload = msg.payload || [];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 710,
        "y": 240,
        "wires": [
            [
                "refugee_http_response"
            ]
        ]
    },
    {
        "id": "refugee_single_response",
        "type": "function",
        "z": "tab_refugees",
        "name": "Format Single",
        "func": "if (msg.payload && msg.payload.length > 0) {\n    msg.statusCode = 200;\n    msg.payload = msg.payload[0];\n} else {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Refugee not found\" };\n}\nreturn msg;",
        "outputs": 1,
        "x": 800,
        "y": 320,
        "wires": [
            [
                "refugee_http_response"
            ]
        ]
    },
    {
        "id": "refugee_http_response",
        "type": "http response",
        "z": "tab_refugees",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1000,
        "y": 360,
        "wires": []
    },
    {
        "id": "assignment_get_by_id",
        "type": "http in",
        "z": "tab_assignments",
        "name": "GET /api/assignments/:id",
        "url": "/api/assignments/:id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 300,
        "wires": [
            [
                "assignment_get_by_id_prepare"
            ]
        ]
    },
    {
        "id": "assignment_get_by_id_prepare",
        "type": "function",
        "z": "tab_assignments",
        "name": "Prepare Query",
        "func": "var idRefugiado = (msg.req && msg.req.params && msg.req.params.id) || msg.payload || 1;\nvar idNumero = parseInt(idRefugiado);\n\nmsg.topic = `SELECT * FROM assignments WHERE refugee_id = $1 ORDER BY created_at DESC`;\n\nmsg.params = [\n    idNumero\n];\n\n// Pasamos los par√°metros al payload para que el nodo Postgres los lea\nmsg.payload = msg.params;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 300,
        "wires": [
            [
                "assignment_get_by_id_query"
            ]
        ]
    },
    {
        "id": "assignment_get_by_id_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "name": "Query Assignment",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 590,
        "y": 300,
        "wires": [
            [
                "assignment_http_response"
            ]
        ]
    },
    {
        "id": "assignment_get_by_refugee",
        "type": "http in",
        "z": "tab_assignments",
        "name": "GET /api/assignments/refugee/:refugeeId",
        "url": "/api/assignments/refugee/:refugeeId",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 200,
        "wires": [
            [
                "assignment_get_by_refugee_prepare"
            ]
        ]
    },
    {
        "id": "assignment_get_by_refugee_prepare",
        "type": "function",
        "z": "tab_assignments",
        "name": "Prepare Query",
        "func": "msg.params = [parseInt(msg.req.params.refugeeId)];\nmsg.topic = \"SELECT a.*, s.name as shelter_name FROM assignments a LEFT JOIN shelters s ON a.shelter_id = s.id WHERE a.refugee_id = $1 ORDER BY a.id DESC\";\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 200,
        "wires": [
            [
                "assignment_get_by_refugee_query"
            ]
        ]
    },
    {
        "id": "assignment_get_by_refugee_query",
        "type": "postgresql",
        "z": "tab_assignments",
        "name": "Query",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 650,
        "y": 200,
        "wires": [
            [
                "assignment_response"
            ]
        ]
    },
    {
        "id": "assignment_response",
        "type": "function",
        "z": "tab_assignments",
        "name": "Format Response",
        "func": "msg.statusCode = 200;\nmsg.payload = msg.payload || [];\nreturn msg;",
        "outputs": 1,
        "x": 830,
        "y": 200,
        "wires": [
            [
                "assignment_http_response"
            ]
        ]
    },
    {
        "id": "assignment_http_response",
        "type": "http response",
        "z": "tab_assignments",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1040,
        "y": 300,
        "wires": []
    },
    {
        "id": "get_ai_recommendation",
        "type": "http in",
        "z": "tab_ai_integration",
        "d": true,
        "name": "GET /api/ai/recommend/:refugeeId",
        "url": "/api/ai/recommend/:refugeeId",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 60,
        "wires": [
            [
                "prepare_refugee_query"
            ]
        ]
    },
    {
        "id": "prepare_refugee_query",
        "type": "function",
        "z": "tab_ai_integration",
        "d": true,
        "name": "Preparar query",
        "func": "const refugeeId = msg.req.params.refugeeId;\nmsg.params = [refugeeId];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 60,
        "wires": [
            [
                "fetch_refugee_for_recommendation"
            ]
        ]
    },
    {
        "id": "fetch_refugee_for_recommendation",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "d": true,
        "name": "Obtener refugiado",
        "query": "SELECT * FROM refugees WHERE id = $1",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 650,
        "y": 60,
        "wires": [
            [
                "check_refugee_exists"
            ]
        ]
    },
    {
        "id": "check_refugee_exists",
        "type": "function",
        "z": "tab_ai_integration",
        "d": true,
        "name": "Verificar refugiado",
        "func": "if (!msg.payload || msg.payload.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: 'Refugiado no encontrado' };\n    return [null, msg];\n}\n\nconst refugee = msg.payload[0];\n\n// Calcular family_size, has_children, children_count\nlet family_size = 1;\nlet has_children = false;\nlet children_count = 0;\n\nif (refugee.family_id) {\n    family_size = 1;\n}\n\n// Preparar payload para el servicio de IA\nmsg.payload = {\n    first_name: refugee.first_name,\n    last_name: refugee.last_name,\n    age: refugee.age,\n    gender: refugee.gender,\n    nationality: refugee.nationality,\n    languages_spoken: refugee.languages_spoken,\n    medical_conditions: refugee.medical_conditions,\n    has_disability: refugee.has_disability,\n    vulnerability_score: refugee.vulnerability_score,\n    special_needs: refugee.special_needs,\n    family_id: refugee.family_id,\n    family_size: family_size,\n    has_children: has_children,\n    children_count: children_count\n};\n\n// Guardar refugee original para la respuesta\nflow.set('originalRefugee', refugee);\n\nreturn [msg, null];",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 60,
        "wires": [
            [
                "call_ai_for_recommendation"
            ]
        ]
    },
    {
        "id": "call_ai_for_recommendation",
        "type": "http request",
        "z": "tab_ai_integration",
        "d": true,
        "name": "Obtener recomendaci√≥n IA",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://shelterai-ai-service:8000/api/recommend",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Content-Type",
                "keyValue": "",
                "valueType": "application/json",
                "valueValue": ""
            }
        ],
        "x": 1120,
        "y": 60,
        "wires": [
            [
                "format_recommendation_response"
            ]
        ]
    },
    {
        "id": "format_recommendation_response",
        "type": "function",
        "z": "tab_ai_integration",
        "d": true,
        "name": "Formatear respuesta",
        "func": "// Obtener los datos del refugiado original\nconst originalRefugee = flow.get('originalRefugee');\nconst aiResponse = msg.payload;\n\nif (!aiResponse || !aiResponse.recommendations || aiResponse.recommendations.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: 'No se encontraron recomendaciones de refugios' };\n    return msg;\n}\n\n// Formatear respuesta en el formato que espera Flutter (RecommendationResponse)\nconst recommendations = aiResponse.recommendations.map(rec => ({\n    shelter_id: rec.shelter_id,\n    shelter_name: rec.shelter_name,\n    address: rec.address || '',\n    compatibility_score: rec.compatibility_score || 0,\n    priority_score: rec.total_score || 0,\n    max_capacity: rec.max_capacity || 0,\n    current_occupancy: rec.current_occupancy || 0,\n    available_space: rec.available_space || 0,\n    occupancy_rate: rec.occupancy_rate || 0,\n    has_medical_facilities: rec.has_medical_facilities === true,\n    has_childcare: rec.has_childcare === true,\n    has_disability_access: rec.has_disability_access === true,\n    languages_spoken: rec.languages_spoken || '',\n    shelter_type: rec.shelter_type || '',\n    services_offered: rec.services_offered || '',\n    explanation: rec.explanation || ''\n}));\n\nmsg.payload = {\n    refugee_name: (originalRefugee.first_name || '') + ' ' + (originalRefugee.last_name || ''),\n    refugee_age: originalRefugee.age || 0,\n    refugee_nationality: originalRefugee.nationality || '',\n    refugee_family_size: 1,\n    refugee_gender: originalRefugee.gender || '',\n    recommendations: recommendations,\n    cluster_id: aiResponse.cluster_id || 0,\n    cluster_label: aiResponse.cluster_label || 'No etiqueta',\n    vulnerability_level: aiResponse.vulnerability_level || 'unknown',\n    total_shelters_analyzed: aiResponse.total_shelters_analyzed || 0,\n    ml_model_version: aiResponse.model_version || '1.0'\n};\n\nmsg.statusCode = 200;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 140,
        "wires": [
            [
                "send_recommendation_response"
            ]
        ]
    },
    {
        "id": "send_recommendation_response",
        "type": "http response",
        "z": "tab_ai_integration",
        "d": true,
        "name": "Enviar respuesta",
        "statusCode": "",
        "headers": {},
        "x": 810,
        "y": 140,
        "wires": []
    },
    {
        "id": "assign_shelter_http_in",
        "type": "http in",
        "z": "tab_ai_integration",
        "name": "POST /api/ai/assign-shelter",
        "url": "/api/ai/assign-shelter",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 560,
        "wires": [
            [
                "assign_shelter_prepare"
            ]
        ]
    },
    {
        "id": "assign_shelter_http_response",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Success Response",
        "statusCode": "200",
        "headers": {},
        "x": 1490,
        "y": 520,
        "wires": []
    },
    {
        "id": "assign_shelter_prepare",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Prepare Update",
        "func": "let body = msg.payload;\nif (typeof body === 'string') {\n  try { body = JSON.parse(body); } catch (e) { body = {}; }\n}\n\nconst rawRefugeeId = body.refugee_id;\nconst rawShelterId = body.shelter_id;\n\nconst refugee_id = Number(rawRefugeeId);\nconst shelter_id = Number(rawShelterId);\n\nif (!Number.isInteger(refugee_id) || !Number.isInteger(shelter_id) || refugee_id <= 0 || shelter_id <= 0) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'refugee_id y shelter_id deben ser enteros > 0' };\n    return [null, msg];\n}\n\n// Preparar query para actualizar refugiado\nmsg.query = `UPDATE refugees \n             SET assigned_shelter_id = $1, \n                 status = 'assigned',\n                 updated_at = NOW()\n             WHERE id = $2\n             RETURNING id, assigned_shelter_id, status`;\n\nmsg.params = [shelter_id, refugee_id];\nmsg.payload = null;\n\nconsole.log('[ASSIGN] Updating refugee', refugee_id, 'with shelter', shelter_id);\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 560,
        "wires": [
            [
                "assign_shelter_query"
            ],
            [
                "assign_shelter_error"
            ]
        ]
    },
    {
        "id": "assign_shelter_query",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "Update Refugee",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 620,
        "y": 520,
        "wires": [
            [
                "assign_shelter_response"
            ]
        ]
    },
    {
        "id": "assign_shelter_response",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Format Response",
        "func": "// 1. Validar que la asignaci√≥n del refugiado funcion√≥ (viene del nodo anterior)\nif (!msg.payload || msg.payload.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: 'Error: No se encontr√≥ el refugiado para actualizar.' };\n    return [null, msg]; // Salida de error\n}\n\nconst result = msg.payload[0];\nconst shelterId = result.assigned_shelter_id;\n\n// 2. GUARDAR DATOS EN LA \"MALETA\"\n// Como vamos a ejecutar otra query ahora, el msg.payload se va a borrar.\n// Guardamos los datos del refugiado aqu√≠ para usarlos al final del todo.\nmsg.datosRefugiado = {\n    refugee_id: result.id,\n    assigned_shelter_id: shelterId,\n    status: result.status\n};\n\n// 3. Preparar la Query para RESTAR AFORO (Update Shelter)\n// Restamos 1 al espacio disponible\nmsg.query = `\n    UPDATE shelters \n    SET available_space = available_space - 1,\n        updated_at = NOW()\n    WHERE id = $1\n`;\n\nmsg.params = [shelterId];\n\n// Limpiamos payload para el siguiente nodo SQL\nmsg.payload = null;\n\nconsole.log(`[LOGIC] Preparando resta de aforo para Shelter ID: ${shelterId}`);\n\n// Pasamos al siguiente nodo (Postgres)\nreturn [msg, null];",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 520,
        "wires": [
            [
                "95cffb18972600be"
            ]
        ]
    },
    {
        "id": "assign_shelter_error",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Error Response",
        "statusCode": "",
        "headers": {},
        "x": 620,
        "y": 600,
        "wires": []
    },
    {
        "id": "95cffb18972600be",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": 1,
        "outputs": 1,
        "x": 1030,
        "y": 520,
        "wires": [
            [
                "aca51ab62bc08951"
            ]
        ]
    },
    {
        "id": "aca51ab62bc08951",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Format Final Response",
        "func": "// Recuperamos los datos que guardamos en la \"maleta\" en el Paso A\nconst datos = msg.datosRefugiado;\n\n// Preparamos la respuesta final bonita para Flutter\nmsg.statusCode = 200;\nmsg.payload = {\n    success: true,\n    refugee_id: datos.refugee_id,\n    assigned_shelter_id: datos.assigned_shelter_id,\n    status: datos.status,\n    message: 'Proceso completo: Refugiado asignado y aforo del refugio actualizado.'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 520,
        "wires": [
            [
                "assign_shelter_http_response",
                "5e96ea5e7035a231"
            ]
        ]
    },
    {
        "id": "41aa3f26b3b03799",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Preparar Correo",
        "func": "// 1. Recuperamos los DATOS PERSONALES (Vienen del nodo Postgres que acabamos de poner)\nvar filas = msg.payload;\nif (!filas || filas.length === 0) {\n    node.warn(\"No se encontr√≥ el refugiado en la BD para enviar email.\");\n    return null; \n}\nconst datosPersonales = filas[0]; // Aqu√≠ est√° first_name, email...\n\n// 2. Recuperamos los DATOS DE ASIGNACI√ìN (Que guardamos en la \"mochila\")\nconst datosAsignacion = msg.assignmentContext || {};\n\n// 3. Extraemos el email\nconst emailDestino = datosPersonales.email;\n\n// SEGURIDAD: Si no hay email, cortamos.\nif (!emailDestino) {\n    node.warn(`El refugiado ${datosPersonales.first_name} no tiene email registrado. No se env√≠a correo.`);\n    return null;\n}\n\n// 4. Preparamos variables para el texto\nconst nombreCompleto = `${datosPersonales.first_name || ''} ${datosPersonales.last_name || ''}`.trim() || 'Refugiado';\n\n// Truco: Si no tenemos el nombre del refugio (porque solo tenemos el ID), ponemos un gen√©rico o el ID.\nconst nombreRefugio = datosAsignacion.shelter_name || `Refugio #${datosAsignacion.shelter_id}`;\nconst explicacion = datosAsignacion.explanation || 'Asignaci√≥n autom√°tica basada en disponibilidad.';\nconst fecha = new Date().toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });\n\n// 5. Configuraci√≥n para el nodo de Email\nmsg.to = emailDestino;\nmsg.topic = `‚úÖ Asignaci√≥n Confirmada - ShelterAI`;\n\n// 6. Cuerpo en Texto Plano\nmsg.payload = `Hola ${nombreCompleto},\n\nTe confirmamos que el sistema ShelterAI te ha asignado plaza en: ${nombreRefugio}.\nMotivo: ${explicacion}\n\nPor favor, acude lo antes posible.\nFecha: ${fecha}`;\n\n// 7. Cuerpo en HTML (Tu dise√±o bonito)\nmsg.html = `\n<div style=\"font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; border: 1px solid #e0e0e0; border-radius: 8px;\">\n    <div style=\"background-color: #2E7D32; padding: 20px; text-align: center;\">\n        <h2 style=\"color: white; margin: 0;\">¬°Asignaci√≥n Confirmada!</h2>\n    </div>\n    <div style=\"padding: 30px;\">\n        <p>Hola <strong>${nombreCompleto}</strong>,</p>\n        <p>Hemos asignado tu plaza exitosamente.</p>\n        \n        <div style=\"background-color: #f1f8e9; border-left: 5px solid #2E7D32; padding: 15px; margin: 20px 0;\">\n            <h3 style=\"margin: 0; color: #1B5E20;\">üìç ${nombreRefugio}</h3>\n            <p style=\"margin-top: 10px; font-style: italic;\">\"${explicacion}\"</p>\n        </div>\n        \n        <p style=\"font-size: 12px; color: #777;\">Fecha: ${fecha}</p>\n    </div>\n</div>\n`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1880,
        "y": 440,
        "wires": [
            [
                "ad8e96e2588a39af"
            ]
        ]
    },
    {
        "id": "ad8e96e2588a39af",
        "type": "e-mail",
        "z": "tab_ai_integration",
        "server": "smtp.gmail.com",
        "port": "587",
        "authtype": "BASIC",
        "saslformat": true,
        "token": "oauth2Response.access_token",
        "secure": false,
        "tls": true,
        "name": "",
        "dname": "",
        "x": 2050,
        "y": 440,
        "wires": []
    },
    {
        "id": "f7d9550979f67a08",
        "type": "http in",
        "z": "tab_ai_integration",
        "name": "POST /api/refugees-with-assignment",
        "url": "/api/refugees-with-assignment",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 700,
        "wires": [
            [
                "b58ca6def0b1b4a3"
            ]
        ]
    },
    {
        "id": "83baf60cae5aa497",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Preparar INSERT refugiado",
        "func": "const data = msg.payload;\n\nmsg.query = `INSERT INTO refugees (first_name, last_name, age, gender, nationality, languages_spoken, email, family_size, has_children, children_count, medical_conditions, requires_medical_facilities, has_disability, special_needs, vulnerability_score, status, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, 'new', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) RETURNING *`;\n\nmsg.params = [\n    data.first_name, \n    data.last_name, \n    data.age, \n    data.gender,\n    data.nationality, \n    data.languages_spoken || null, \n    data.email || null,\n    data.family_size || 1,\n    data.has_children || false,\n    data.children_count || 0,\n    data.medical_conditions || null,\n    data.requires_medical_facilities || false,\n    data.has_disability || false,\n    data.special_needs || null, \n    data.vulnerability_score || 0\n];\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 700,
        "wires": [
            [
                "c663a95531a34404"
            ]
        ]
    },
    {
        "id": "c663a95531a34404",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "Guardar refugiado",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 770,
        "y": 700,
        "wires": [
            [
                "f3ba1097f96e6329"
            ]
        ]
    },
    {
        "id": "b0dcf0fe6b4aa77b",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Respuesta HTTP",
        "statusCode": "",
        "headers": {},
        "x": 1210,
        "y": 700,
        "wires": []
    },
    {
        "id": "f3ba1097f96e6329",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Format Response",
        "func": "// 1. Recuperamos el resultado de la base de datos\nvar rows = msg.payload;\n\n// 2. Verificaci√≥n de seguridad (Blindaje)\n// Si el array est√° vac√≠o, significa que el INSERT fall√≥ silenciosamente.\nif (!rows || rows.length === 0) {\n    var errorMsg = \"Error: La base de datos no devolvi√≥ el refugiado creado.\";\n    \n    // Forzamos el error para que salte al nodo CATCH (si lo tienes)\n    node.error(new Error(errorMsg), msg);\n    \n    // O preparamos una respuesta de error manual si no usas Catch\n    msg.statusCode = 500;\n    msg.payload = { \n        success: false, \n        error: errorMsg \n    };\n    return msg;\n}\n\n// 3. Extraemos el objeto creado (siempre es el primero del array)\nvar newRefugee = rows[0];\n\n// 4. Construimos la respuesta HTTP (Est√°ndar REST)\nmsg.statusCode = 201; // C√≥digo 201 significa \"Created\" (Creado exitosamente)\nmsg.payload = {\n    success: true,\n    message: \"Refugiado registrado correctamente\",\n    // Devolvemos el objeto completo. Es muy √∫til para que Flutter \n    // pueda actualizar la lista local sin tener que recargar internet.\n    data: newRefugee \n};\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 700,
        "wires": [
            [
                "b0dcf0fe6b4aa77b"
            ]
        ]
    },
    {
        "id": "5e96ea5e7035a231",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Format GET refugee",
        "func": "// 1. Recuperamos la info de la asignaci√≥n (del nodo anterior)\n// Asumimos que msg.payload es el resultado del UPDATE o el objeto que creaste\nvar asignacion = msg.payload;\n\n// Si viene de un nodo Postgres puro, suele ser un array, cogemos el primero\nif (Array.isArray(asignacion)) {\n    asignacion = asignacion[0];\n}\n\n// 2. GUARDAR CONTEXTO (¬°Importante!)\n// Guardamos la info de la asignaci√≥n en una propiedad aparte 'msg.assignmentContext'\n// para que sobreviva a la siguiente consulta SQL.\nmsg.assignmentContext = {\n    refugee_id: asignacion.refugee_id || msg.refugee_id, // Asegura tener el ID\n    shelter_id: asignacion.assigned_shelter_id,\n    shelter_name: asignacion.shelter_name, // Si lo tienes. Si no, saldr√° undefined.\n    explanation: \"Asignaci√≥n prioritaria por vulnerabilidad\" // O el dato real si lo tienes\n};\n\n// 3. Preparar la Query para obtener EMAIL y NOMBRE\n// Usamos el refugee_id para buscar sus datos personales en la tabla 'refugees'\nmsg.query = \"SELECT first_name, last_name, email FROM refugees WHERE id = $1\";\nmsg.params = [msg.assignmentContext.refugee_id];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1480,
        "y": 440,
        "wires": [
            [
                "ac43cf5439c90925"
            ]
        ]
    },
    {
        "id": "ac43cf5439c90925",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": 1,
        "outputs": 1,
        "x": 1690,
        "y": 440,
        "wires": [
            [
                "41aa3f26b3b03799"
            ]
        ]
    },
    {
        "id": "3487802549c54a73",
        "type": "http in",
        "z": "tab_ai_integration",
        "name": "GET /api/ai/recommend/:refugeeId",
        "url": "/api/ai/recommend/:refugeeId",
        "method": "get",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 220,
        "wires": [
            [
                "a0f919fb54ea63ae"
            ]
        ]
    },
    {
        "id": "a0f919fb54ea63ae",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Prepare ID",
        "func": "const refugeeId = msg.req.params.refugeeId;\nmsg.params = [refugeeId];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 220,
        "wires": [
            [
                "14b75a1e37d6e733"
            ]
        ]
    },
    {
        "id": "14b75a1e37d6e733",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "Get Refugee DB",
        "query": "SELECT * FROM refugees WHERE id = $1",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 220,
        "wires": [
            [
                "ab9b2f97ef6f4fdc"
            ]
        ]
    },
    {
        "id": "ab9b2f97ef6f4fdc",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Preparare Payload IA",
        "func": "if (!msg.payload || msg.payload.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: 'Refugiado no encontrado' };\n    return [null, msg];\n}\n\nconst refugee = msg.payload[0];\n// Guardamos el refugiado original para usar su nombre al final\nflow.set('tempRefugeeInfo', refugee);\n\n// AQUI ADAPTAMOS LOS DATOS A LO QUE ESPERA EL MODELO NUEVO\n// El modelo espera un JSON con features. Le enviamos los datos raw\n// y dejamos que la API de Python los procese.\nmsg.payload = {\n    person_id: refugee.id,\n    age: refugee.age,\n    gender: refugee.gender,\n    nationality: refugee.nationality,\n    medical_conditions: refugee.medical_conditions,\n    has_disability: refugee.has_disability,\n    special_needs: refugee.special_needs,\n    // A√±adimos campos clave para el clustering si existen\n    vulnerability_score: refugee.vulnerability_score || 0\n};\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 220,
        "wires": [
            [
                "f329200600f357ec"
            ],
            [
                "2123731b476fc94e"
            ]
        ]
    },
    {
        "id": "f329200600f357ec",
        "type": "http request",
        "z": "tab_ai_integration",
        "name": "POST /api/cluster",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://ai-service:8000/api/cluster",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "Content-Type",
                "keyValue": "",
                "valueType": "application/json",
                "valueValue": ""
            }
        ],
        "x": 270,
        "y": 300,
        "wires": [
            [
                "d2fe4496af634b12"
            ]
        ]
    },
    {
        "id": "d2fe4496af634b12",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "TRADUCTOR (IA -> SQL)",
        "func": "// 1. Recuperamos datos: Respuesta IA y Datos Originales del Refugiado\nvar aiResponse = msg.payload;\nvar clusterId = aiResponse.cluster.cluster_id;\nvar refugee = flow.get('tempRefugeeInfo') || {}; // Recuperamos los datos crudos de SQL\n\n// 2. Definimos las reglas base de la IA\n// Asumimos por defecto lo que hemos aprendido (5 = Family)\nvar needs = [];\nconst CLUSTER_RULES = {\n    \"5\":  [\"FAMILY\"], \n    \"6\":  [\"ACCESSIBLE\", \"ELDERLY_CARE\"],\n    \"17\": [\"FAMILY\", \"ACCESSIBLE\", \"ELDERLY_CARE\"],\n    \"24\": [\"FAMILY\", \"ELDERLY_CARE\"],\n    \"1\":  [\"LEGAL_SUPPORT\"],\n    \"3\":  [\"MEDICAL\"]\n};\n\nneeds = CLUSTER_RULES[clusterId] || [];\n\n// =========================================================\n// 3. L√ìGICA H√çBRIDA DE CORRECCI√ìN (Hybrid AI Verification)\n// =========================================================\n// La IA puede equivocarse. Usamos reglas deterministas para corregir casos graves.\n\n// CASO IVAN: Si la IA dice \"FAMILY\" (Cl√∫ster 5) pero el refugiado NO tiene hijos...\nif (needs.includes(\"FAMILY\")) {\n    if (refugee.has_children === false && refugee.family_size === 1) {\n        // ¬°Error de la IA detectado! Quitamos la etiqueta FAMILY\n        needs = needs.filter(n => n !== \"FAMILY\");\n        \n        // Aplicamos reglas de seguridad basadas en datos reales\n        if (refugee.has_disability === true) needs.push(\"ACCESSIBLE\");\n        if (refugee.age > 60) needs.push(\"ELDERLY_CARE\");\n        if (refugee.medical_conditions && refugee.medical_conditions !== 'None') needs.push(\"MEDICAL\");\n    }\n}\n\n// CASO GENERAL: Si tiene discapacidad f√≠sica, SIEMPRE forzamos accesibilidad\n// independientemente de lo que diga el cl√∫ster.\nif (refugee.has_disability === true && !needs.includes(\"ACCESSIBLE\")) {\n    needs.push(\"ACCESSIBLE\");\n}\n// =========================================================\n\nvar explanation = [];\n\n// 4. Construimos la Query SQL Din√°mica\nvar sql = \"SELECT * FROM shelters WHERE available_space > 0\";\n\nif (needs.includes(\"ACCESSIBLE\")) {\n    sql += \" AND has_disability_access = true\";\n    explanation.push(\"Accesibilidad requerida\");\n}\nif (needs.includes(\"FAMILY\")) {\n    sql += \" AND (type = 'family' OR has_childcare = true)\"; \n    explanation.push(\"Unidad familiar\");\n}\nif (needs.includes(\"MEDICAL\")) {\n    sql += \" AND has_medical_facilities = true\";\n    explanation.push(\"Atenci√≥n m√©dica\");\n}\nif (needs.includes(\"ELDERLY_CARE\")) {\n     // Si tienes refugios espec√≠ficos para ancianos usa type='special_care'\n     // Si no, podemos priorizar los que tienen servicios m√©dicos\n     if (!needs.includes(\"MEDICAL\")) sql += \" AND has_medical_facilities = true\";\n     explanation.push(\"Cuidado de mayores\");\n}\n\nsql += \" ORDER BY available_space DESC LIMIT 3\";\n\nmsg.query = sql;\n\n// Guardamos contexto\nmsg.aiContext = {\n    cluster_id: clusterId,\n    needs: needs,\n    explanation: explanation.join(\", \") || \"Asignaci√≥n por disponibilidad general\"\n};\n\n// Limpieza de par√°metros SQL\nmsg.params = []; \n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 300,
        "wires": [
            [
                "fd491f2c5c499e5e"
            ]
        ]
    },
    {
        "id": "fd491f2c5c499e5e",
        "type": "postgresql",
        "z": "tab_ai_integration",
        "name": "Search Refugees",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 710,
        "y": 300,
        "wires": [
            [
                "0943016d52547831"
            ]
        ]
    },
    {
        "id": "0943016d52547831",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Format for Flutter",
        "func": "// Recuperamos datos\nconst shelters = msg.payload || [];\nconst originalRefugee = flow.get('tempRefugeeInfo') || {};\nconst contexttt = msg.aicontextt || {};\n\n// Mapeamos los refugios encontrados al formato RecommendationResponse\nconst recommendations = shelters.map(s => ({\n    shelter_id: s.id,\n    shelter_name: s.name,\n    address: s.address || \"Ubicaci√≥n confidencial\",\n    // Simulamos score ya que ahora es por l√≥gica estricta\n    compatibility_score: 95, \n    available_space: s.available_space,\n    max_capacity: s.capacity,\n    has_medical_facilities: s.has_medical_facilities,\n    has_disability_access: s.has_disability_access,\n    explanation: contexttt.explanation\n}));\n\n// Respuesta Final JSON\nmsg.payload = {\n    refugee_name: `${originalRefugee.first_name} ${originalRefugee.last_name}`,\n    cluster_id: contexttt.cluster_id,\n    cluster_label: contexttt.needs.join(\", \") || \"Est√°ndar\",\n    vulnerability_level: contexttt.needs.length > 0 ? \"High\" : \"Standard\",\n    recommendations: recommendations,\n    message: recommendations.length > 0 ? \"Refugios encontrados\" : \"Sin disponibilidad\"\n};\n\nmsg.statusCode = 200;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 300,
        "wires": [
            [
                "2123731b476fc94e"
            ]
        ]
    },
    {
        "id": "2123731b476fc94e",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Response",
        "statusCode": "",
        "headers": {},
        "x": 1120,
        "y": 240,
        "wires": []
    },
    {
        "id": "b58ca6def0b1b4a3",
        "type": "json-schema-validator",
        "z": "tab_ai_integration",
        "name": "",
        "func": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"first_name\": { \"type\": \"string\", \"minLength\": 1 },\n        \"last_name\": { \"type\": \"string\", \"minLength\": 1 },\n        \"age\": { \"type\": \"integer\", \"minimum\": 0 },\n        \"gender\": { \"type\": \"string\", \"enum\": [\"Male\", \"Female\", \"Other\"] },\n        \"nationality\": { \"type\": \"string\" },\n        \"family_size\": { \"type\": \"integer\", \"minimum\": 1 },\n        \"has_children\": { \"type\": \"boolean\" }\n    },\n    \"required\": [\"first_name\", \"last_name\", \"age\", \"gender\", \"nationality\"]\n}",
        "x": 350,
        "y": 780,
        "wires": [
            [
                "83baf60cae5aa497"
            ]
        ]
    },
    {
        "id": "catch_validation_error",
        "type": "catch",
        "z": "tab_ai_integration",
        "name": "Capturar Error Validaci√≥n",
        "scope": [
            "f7d9550979f67a08"
        ],
        "uncaught": false,
        "x": 400,
        "y": 1020,
        "wires": [
            [
                "format_400_error"
            ]
        ]
    },
    {
        "id": "format_400_error",
        "type": "function",
        "z": "tab_ai_integration",
        "name": "Generar Error 400",
        "func": "msg.statusCode = 400;\nmsg.payload = {\n    error: \"Bad Request\",\n    message: \"Schema Validation Failed: Los datos enviados no cumplen el formato requerido.\",\n    details: msg.error.message // Aqu√≠ Node-RED guarda el detalle del fallo\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 1020,
        "wires": [
            [
                "http_response_error"
            ]
        ]
    },
    {
        "id": "http_response_error",
        "type": "http response",
        "z": "tab_ai_integration",
        "name": "Respuesta Error",
        "statusCode": "",
        "headers": {},
        "x": 840,
        "y": 1020,
        "wires": []
    },
    {
        "id": "login_validation",
        "type": "function",
        "z": "tab_login",
        "name": "Validar y Preparar",
        "func": "// Function: Validar y Preparar Login\n\n// 1. Validar que llegue algo\nif (!msg.payload || typeof msg.payload !== 'object') {\n  // Usamos node.error para activar el nodo Catch si lo tienes configurado\n  // O devolvemos el error directo si vas al HTTP Response.\n  msg.statusCode = 400;\n  msg.payload = { success: false, message: 'Datos inv√°lidos' };\n  \n  // OPCI√ìN A: Si usas Catch, descomenta la siguiente l√≠nea y pon return null\n  // node.error(\"Datos inv√°lidos\", msg); return null; \n  \n  // OPCI√ìN B (La actual): Devolver msg PERO aseg√∫rate de no conectarlo al nodo Postgres\n  return msg; \n}\n\n// 2. Extracci√≥n Inteligente + LIMPIEZA (.trim())\n// Esto elimina espacios en blanco al inicio o final (s√∫per com√∫n en m√≥viles)\nlet identifier = msg.payload.identifier || msg.payload.email || msg.payload.username || msg.payload.phone_number;\n\nif (typeof identifier === 'string') {\n    identifier = identifier.trim();\n}\n\nconst password = msg.payload.password;\n\n// 3. Validaci√≥n de campos requeridos\nif (!identifier || !password || typeof password !== 'string' || password.length === 0) {\n  msg.statusCode = 400;\n  msg.payload = {\n    success: false,\n    message: 'Error: Debes introducir usuario/email/tel√©fono y contrase√±a.'\n  };\n  \n  // Si validaci√≥n falla, cortamos aqu√≠.\n  // IMPORTANTE: Conecta una salida de este nodo directa al HTTP Response para estos casos,\n  // o usa node.error() como vimos antes.\n  return msg;\n}\n\n// 4. Guardar password para verificar despu√©s (Bcrypt)\nmsg.passwordToVerify = password;\n\n// 5. Query Multiuso\n// Buscamos coincidencia en CUALQUIERA de las 3 columnas\nmsg.query = 'SELECT id, email, username, password, first_name, last_name, role FROM users WHERE email = $1 OR username = $1 OR phone_number = $1';\nmsg.params = [identifier];\n\n// 6. Limpieza para seguridad\nmsg.payload = null;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 100,
        "wires": [
            [
                "login_db_query"
            ]
        ]
    },
    {
        "id": "login_db_query",
        "type": "postgresql",
        "z": "tab_login",
        "name": "Consultar Usuario",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 650,
        "y": 100,
        "wires": [
            [
                "login_verify"
            ]
        ]
    },
    {
        "id": "login_verify",
        "type": "function",
        "z": "tab_login",
        "name": "Verificar y Responder",
        "func": "// El nodo PostgreSQL devuelve un array con las filas insertadas\nvar filas = msg.payload;\n\ntry {\n  if (filas && filas.length > 0) {\n    var usuarioNuevo = filas[0];\n\n    // √âXITO: Construimos la respuesta 201\n    msg.statusCode = 201;\n    msg.payload = {\n      \"success\": true,\n      \"user_id\": usuarioNuevo.id,\n      \"first_name\": usuarioNuevo.first_name,\n      \"last_name\": usuarioNuevo.last_name,\n      \"username\": usuarioNuevo.username,\n      \"email\": usuarioNuevo.email,\n      \"role\": usuarioNuevo.role,\n      \"token\": \"simulated_token_\" + Date.now()\n    };\n\n    // Devolvemos el mensaje por la salida normal\n    return msg;\n\n  } else {\n    // ERROR: No hay filas. \n    // Aqu√≠ es donde FORZAMOS la llamada al nodo Catch.\n\n    var errorMsg = \"No se pudo recuperar el usuario creado (la base de datos no devolvi√≥ filas)\";\n\n    // 1. Preparamos el mensaje de error para el Catch\n    // (El nodo Catch recibir√° esto en msg.error)\n    var err = new Error(errorMsg);\n\n    // 2. Avisamos a Node-RED de que ha habido un error.\n    // El segundo par√°metro 'msg' se pasa al nodo Catch para que no pierdas los datos.\n    node.error(err, msg);\n\n    // 3. Devolvemos null para CORTAR el flujo normal.\n    // As√≠ no sigue hacia el nodo HTTP Response de √©xito, sino que salta al Catch.\n    return null;\n  }\n} catch (e) {\n  // Si hay un error de c√≥digo imprevisto (ej: variable undefined), tambi√©n lo mandamos al Catch\n  node.error(e, msg);\n  return null;\n}// El nodo PostgreSQL devuelve un array con las filas insertadas\n// gracias al \"RETURNING\" que pusimos en la query.\nvar filas = msg.payload;\n\nif (filas && filas.length > 0) {\n  var usuarioNuevo = filas[0];\n\n  // Construimos la respuesta EXACTAMENTE igual que en el Login\n  // As√≠ el frontend puede guardar el token y entrar directamente.\n  msg.statusCode = 201; // 201 Created (es lo correcto para registros)\n  msg.payload = {\n    \"success\": true,\n    \"user_id\": usuarioNuevo.id,\n    \"first_name\": usuarioNuevo.first_name,\n    \"last_name\": usuarioNuevo.last_name,\n    \"username\": usuarioNuevo.username,\n    \"email\": usuarioNuevo.email,\n    \"role\": usuarioNuevo.role, // Ser√° 'refugee'\n    \"token\": \"simulated_token_\" + Date.now() // Token para que entre directo\n  };\n} else {\n  // Si por lo que sea no devuelve filas (raro si no dio error antes)\n  msg.statusCode = 500;\n  msg.payload = { \"error\": \"No se pudo recuperar el usuario creado\" };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 100,
        "wires": [
            [
                "login_http_response",
                "63d32f953f6537d2"
            ]
        ]
    },
    {
        "id": "login_http_response",
        "type": "http response",
        "z": "tab_login",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1110,
        "y": 100,
        "wires": []
    },
    {
        "id": "22c0c426bf478142",
        "type": "http in",
        "z": "tab_login",
        "name": "POST /api/register (worker)",
        "url": "/api/register",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 300,
        "wires": [
            [
                "e2216cfe7183366c"
            ]
        ]
    },
    {
        "id": "e2216cfe7183366c",
        "type": "function",
        "z": "tab_login",
        "name": "Validar y Preparar",
        "func": "// 1. Extraemos los datos del Frontend\n// Flutter env√≠a: { name: \"Juan P√©rez\", email: \"...\", password: \"...\" }\nvar payload = msg.payload || {};\n\nvar rawName = payload.name || \"\";\nvar email = payload.email;\nvar password = payload.password;\n\n// 2. Validaci√≥n de seguridad b√°sica\nif (!email || !password || !rawName) {\n    msg.statusCode = 400;\n    msg.payload = { error: \"Faltan datos obligatorios: Nombre, Email y Contrase√±a\" };\n    // Cortamos el flujo para no intentar insertar nada\n    return [null, msg];\n}\n\n// 3. TRANSFORMACI√ìN DE DATOS (Adaptaci√≥n a tu Base de Datos)\n\n// A) Generar Username Autom√°tico\n// La tabla pide 'username' UNIQUE, pero el form de trabajador no lo pide.\n// Lo creamos usando la parte anterior al @ del email.\n// Ej: juan@ong.org -> username: juan\nvar autoUsername = email.split('@')[0];\n\n// B) Separar Nombre y Apellido\n// La tabla tiene 'first_name' y 'last_name', pero Flutter env√≠a 'name' junto.\nvar parts = rawName.trim().split(\" \");\nvar firstName = parts[0]; // La primera palabra\nvar lastName = parts.slice(1).join(\" \") || \"\"; // El resto, o vac√≠o si no tiene apellido\n\n// 4. Query SQL\n// Insertamos en: first_name, last_name, username, email, password, role.\n// role lo fijamos a 'worker'.\nmsg.query = `\n    INSERT INTO users (\n        first_name, \n        last_name, \n        username, \n        email, \n        password, \n        role,\n        phone_number\n    ) \n    VALUES ($1, $2, $3, $4, $5, 'worker', NULL) \n    RETURNING id, username, email, role, first_name, last_name\n`;\n\n// 5. Par√°metros (En el orden exacto de los $1, $2...)\nmsg.params = [\n    firstName,     // $1\n    lastName,      // $2\n    autoUsername,  // $3 (Generado)\n    email,         // $4\n    password,      // $5\n];\n\n// 6. Limpieza\nmsg.payload = {};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 300,
        "wires": [
            [
                "78899a30e92aecbe"
            ]
        ]
    },
    {
        "id": "78899a30e92aecbe",
        "type": "postgresql",
        "z": "tab_login",
        "name": "Consultar Usuario",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 640,
        "y": 300,
        "wires": [
            [
                "5e41704bfdb79d59"
            ]
        ]
    },
    {
        "id": "5e41704bfdb79d59",
        "type": "function",
        "z": "tab_login",
        "name": "Verificar y Responder",
        "func": "// El nodo PostgreSQL devuelve un array con las filas insertadas\nvar filas = msg.payload;\n\ntry {\n    if (filas && filas.length > 0) {\n        var usuarioNuevo = filas[0];\n\n        // √âXITO: Construimos la respuesta 201\n        msg.statusCode = 201;\n        msg.payload = {\n            \"success\": true,\n            \"user_id\": usuarioNuevo.id,\n            \"name\": usuarioNuevo.full_name,\n            \"email\": usuarioNuevo.email,\n            \"role\": usuarioNuevo.role,\n            \"token\": \"simulated_token_\" + Date.now()\n        };\n\n        // Devolvemos el mensaje por la salida normal\n        return msg;\n\n    } else {\n        // ERROR: No hay filas. \n        // Aqu√≠ es donde FORZAMOS la llamada al nodo Catch.\n\n        var errorMsg = \"No se pudo recuperar el usuario creado (la base de datos no devolvi√≥ filas)\";\n\n        // 1. Preparamos el mensaje de error para el Catch\n        // (El nodo Catch recibir√° esto en msg.error)\n        var err = new Error(errorMsg);\n\n        // 2. Avisamos a Node-RED de que ha habido un error.\n        // El segundo par√°metro 'msg' se pasa al nodo Catch para que no pierdas los datos.\n        node.error(err, msg);\n\n        // 3. Devolvemos null para CORTAR el flujo normal.\n        // As√≠ no sigue hacia el nodo HTTP Response de √©xito, sino que salta al Catch.\n        return null;\n    }\n} catch (e) {\n    // Si hay un error de c√≥digo imprevisto (ej: variable undefined), tambi√©n lo mandamos al Catch\n    node.error(e, msg);\n    return null;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1020,
        "y": 300,
        "wires": [
            [
                "cb383e10764124f8"
            ]
        ]
    },
    {
        "id": "cb383e10764124f8",
        "type": "http response",
        "z": "tab_login",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1250,
        "y": 300,
        "wires": []
    },
    {
        "id": "63d32f953f6537d2",
        "type": "function",
        "z": "tab_login",
        "name": "Preparar Correo",
        "func": "// Function: Preparar Alerta de Login\n\n// En el flujo de login, el payload suele traer el usuario tras la verificaci√≥n\nconst user = msg.payload;\nconst email = user.email;\n\n// Validaci√≥n de seguridad\nif (!email) {\n    node.warn('Login Email: No hay email en el payload');\n    return null; // Detenemos el flujo para no romper el nodo Gmail\n}\n\nconst fullName = user.name || 'Usuario';\nconst time = new Date().toLocaleTimeString();\nconst date = new Date().toLocaleDateString();\n\n// Configuraci√≥n para node-red-node-email\nmsg.to = email;\nmsg.topic = 'Alerta de Seguridad: Nuevo inicio de sesi√≥n - ShelterAI';\n\n// Cuerpo Texto (Fallback)\nmsg.payload = `Hola ${fullName},\nSe ha detectado un nuevo inicio de sesi√≥n en tu cuenta de ShelterAI.\nFecha: ${date}\nHora: ${time}\n\nSi no has sido t√∫, contacta con un administrador inmediatamente.`;\n\n// Cuerpo HTML (Bonito)\nmsg.html = `\n<h3>Hola, ${fullName}</h3>\n<p>Se ha detectado un nuevo acceso a tu cuenta.</p>\n<div style=\"background-color: #fff3cd; color: #856404; padding: 15px; border-radius: 5px; border: 1px solid #ffeeba;\">\n  <strong>Nuevo Inicio de Sesi√≥n</strong><br>\n  <ul>\n    <li><strong>Fecha:</strong> ${date}</li>\n    <li><strong>Hora:</strong> ${time}</li>\n  </ul>\n</div>\n<p>Si has sido t√∫, puedes ignorar este mensaje.</p>\n<p style=\"font-size: 12px; color: #666;\">Equipo de Seguridad ShelterAI</p>\n`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 200,
        "wires": [
            [
                "dc46be29a6f0c76e"
            ]
        ]
    },
    {
        "id": "91b170f70235ff3c",
        "type": "http in",
        "z": "tab_login",
        "name": "POST /api/login",
        "url": "/api/login",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 100,
        "wires": [
            [
                "login_validation"
            ]
        ]
    },
    {
        "id": "dc46be29a6f0c76e",
        "type": "e-mail",
        "z": "tab_login",
        "server": "smtp.gmail.com",
        "port": "587",
        "authtype": "BASIC",
        "saslformat": true,
        "token": "oauth2Response.access_token",
        "secure": false,
        "tls": true,
        "name": "",
        "dname": "",
        "x": 1290,
        "y": 200,
        "wires": []
    },
    {
        "id": "a6799ab6ebc69493",
        "type": "http in",
        "z": "tab_login",
        "name": "POST /api/register-refugee",
        "url": "/api/register-refugee",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 400,
        "wires": [
            [
                "9e799a512b71a198"
            ]
        ]
    },
    {
        "id": "9e799a512b71a198",
        "type": "function",
        "z": "tab_login",
        "name": "Validar y Preparar",
        "func": "// 1. Extraemos y limpiamos los datos\nvar payload = msg.payload || {};\n\n// Campos obligatorios (seg√∫n tu l√≥gica de negocio)\nvar firstName = payload.first_name;\nvar lastName = payload.last_name || \"\"; // Puede estar vac√≠o\nvar username = payload.username;\nvar password = payload.password;\n\n// Generamos full_name autom√°ticamente para que la BD est√© ordenada\nvar fullName = (firstName + \" \" + lastName).trim();\n\n// Campos Opcionales (convertimos vac√≠os a null para Postgres)\nvar email = payload.email || null;\nvar phone = payload.phone_number || null;\nvar address = payload.address || null;\n\n// Convertir edad a entero (seguridad)\nvar age = (payload.age && !isNaN(payload.age)) ? parseInt(payload.age) : null;\nvar gender = payload.gender || null;\n\n// 2. Validaci√≥n de Seguridad (Solo lo estrictamente obligatorio)\n// Quitamos address y age de aqu√≠ porque en el formulario eran opcionales\nif (!username || !password || !firstName) {\n    msg.statusCode = 400;\n    msg.payload = { \n        success: false,\n        error: \"Faltan datos obligatorios: Usuario, Contrase√±a o Nombre.\" \n    };\n    // Importante: Usamos node.error o return null para no activar el nodo SQL\n    return [null, msg]; \n}\n\n// 3. Query SQL (Solo columnas que existen en tabla users)\nmsg.query = `\n    INSERT INTO users (\n        first_name, last_name, \n        username, email, password, \n        phone_number, \n        role\n    ) \n    VALUES ($1, $2, $3, $4, $5, $6, 'refugee') \n    RETURNING id, first_name, last_name, username, email, role\n`;\n\n// 4. Par√°metros (6 valores)\nmsg.params = [\n    firstName,  // $1\n    lastName,   // $2\n    username,   // $3\n    email,      // $4\n    password,   // $5\n    phone       // $6\n];\n\n// 5. Limpieza\nmsg.payload = null;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 400,
        "wires": [
            [
                "edbf42abf00626cf"
            ]
        ]
    },
    {
        "id": "edbf42abf00626cf",
        "type": "postgresql",
        "z": "tab_login",
        "name": "Consultar Usuario",
        "query": "",
        "postgreSQLConfig": "301245f94e1239d9",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 650,
        "y": 400,
        "wires": [
            [
                "5e41704bfdb79d59"
            ]
        ]
    },
    {
        "id": "69a2ff37382fd8d7",
        "type": "catch",
        "z": "tab_login",
        "name": "",
        "scope": null,
        "uncaught": false,
        "x": 1060,
        "y": 640,
        "wires": [
            [
                "30cff48a648b2fb3"
            ]
        ]
    },
    {
        "id": "30cff48a648b2fb3",
        "type": "debug",
        "z": "tab_login",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1240,
        "y": 640,
        "wires": []
    }
]